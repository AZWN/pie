/// Paths
data Path = java mb.pipeline.Path {
  func uri()           : string
  func resolve(string) : Path
}
func resolve(string) : Path = java mb.pipeline.Path#resolve
func read(Path) : string = java lol#lol // TODO: map to actual java class
func copy(from : Path, to : Path) : to : Path = java lol#lol // TODO: map to actual java class

/// Languages
transient data LangImpl = java org.metaborg.core.language.ILanguageImpl {
  func id() : LangId
}
data LangId = java org.metaborg.core.language.LanguageIdentifier {}
func load-lang(Path) : LangImpl = java mb.pipeline.LoadLang#build


/// Projects
transient data Project = java org.metaborg.core.project.IProject {}
func load-proj(Path) : Project = java mb.pipeline.LoadProject#build
func project-path(Project): Path = java lol#lol // TODO: map to actual java class

/// Parsing
data Ast = java org.spoofax.interpreter.terms.IStrategoTerm {}
func parse(langId : LangId, file : Path, text : string) : ast : Ast? = java mb.pipeline.Parse#build


/// Analysis
func analyze(langId : LangId, project : Path, path : Path, ast : Ast?) : ast : Ast? = java mb.pipeline.Analyze#build


/// Transformation
data Goal = java org.metaborg.core.action.ITransformGoal {}

data CompileGoal : Goal = java org.metaborg.core.action.CompileGoal {}
func make-compile-goal() : CompileGoal = java org.metaborg.core.action.CompileGoal#create

data NamedGoal : Goal = java org.metaborg.core.action.EndNamedGoal {}
func make-named-goal(string) : NamedGoal = java org.metaborg.core.action.NamedGoal#create

func transform(langId : LangId, project : Path, file : Path, ast : Ast?, goal : Goal) : ast : Ast?, writtenFile : Path? = java mb.pipeline.Trans#build


/// Sdf2Table
func sdf2table(input : Path?, target : Path) : output : Path = java mb.pipeline.Sdf2Table#build


/// Configuration build
func build-lang-config(langSpec : Path) : = {
  config : Path = langSpec.resolve("metaborg.yaml");
  output : Path = langSpec.resolve("src-gen/metaborg.component.yaml");
  copy(config, output);
}


/// ESV build
func build-lang-esv(langSpec : Path, esv : Path) : = {
  mainPath : Path     = langSpec.resolve("editor/Main.esv");
  text     : string   = read(mainPath);
  
  lang   : LangImpl = load-lang(esv);
  langId : LangId   = lang.id();
  ast    : Ast?     = parse(langId, mainPath, text);
  if(ast == null) {
    // TODO: ast can be null, need to fail this function call here.
  }

  project     : Project = load-proj(langSpec);
  projectPath : Path    = project-path(project);

  goal : Goal = make-compile-goal();
  transform(langId, projectPath, mainPath, ast, goal);
}


/// SDF build
func build-lang-sdf(langSpec : Path, sdf : Path, langName : string) : = {
  mainPath  : Path     = langSpec.resolve("syntax/{langName}.sdf3");
  text      : string   = read(mainPath);
  
  lang      : LangImpl = load-lang(sdf);
  langId    : LangId   = lang.id();
  parsedAst : Ast?     = parse(langId, mainPath, text);
  if(parsedAst == null) {
    // TODO: fail build
  }

  project     : Project = load-proj(langSpec);
  projectPath : Path    = project-path(project);
  analyzedAst : Ast?    = analyze(langId, projectPath, mainPath, parsedAst);
  if(analyzedAst == null) {
    // TODO: fail build
  }

  goal : Goal = make-named-goal("to Normal Form (abstract)");
  _ : Ast?, normalizedSdfPath : Path? = transform(langId, projectPath, mainPath, analyzedAst, goal);

  parseTablePath : Path = langSpec.resolve("target/metaborg/sdf.tbl");
  outputPath     : Path = sdf2table(normalizedSdfPath, parseTablePath);
}

/// Parsing
func parse-program(langSpec : Path, file : Path) : ast : Ast? = {
  text   : string   = read(file);
  lang   : LangImpl = load-lang(langSpec);
  langId : LangId   = lang.id();
  ast    : Ast?     = parse(langId, file, text);
  return ast;
}


/// Pipeline combiner
func pipeline(langSpec: Path, langName : string, esv : Path, sdf : Path, file : Path) : ast : Ast? = {
  build-lang-config(langSpec);
  build-lang-esv(langSpec, esv);
  build-lang-sdf(langSpec, sdf, langName);
  ast : Ast? = parse-program(langSpec, file);
  return ast;
}
