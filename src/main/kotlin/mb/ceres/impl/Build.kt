package mb.ceres.impl

import com.google.inject.Injector
import mb.ceres.*
import java.util.*

interface Build {
  fun <I : In, O : Out> require(app: BuildApp<I, O>): BuildInfo<I, O>
}

open class BuildImpl(
  private val store: BuildStore,
  private val cache: BuildCache,
  private val share: BuildShare,
  private val reporter: BuildReporter,
  private val builders: Map<String, UBuilder>,
  private val injector: Injector)
  : Build {
  private val consistent = mutableMapOf<UBuildApp, UBuildRes>()
  private val stack = mutableSetOf<UBuildApp>()

  override fun <I : In, O : Out> require(app: BuildApp<I, O>): BuildInfo<I, O> {
    try {
      reporter.require(app)

      if (stack.contains(app)) {
        throw CyclicDependencyException("""Cyclic dependency.
  Requirement of:

    $app

  from requirements:

    ${stack.joinToString(" -> ")}

  creates cycle
""")
      }
      stack.add(app)

      val consistentResult = consistent[app]?.cast<I, O>()
      if (consistentResult != null) {
        // Existing result is known to be consistent this build: reuse
        return BuildInfo(consistentResult)
      }

      val existingResult = (cache[app] ?: store.produces(app))?.cast<I, O>()
      @Suppress("FoldInitializerAndIfToElvis")
      if (existingResult == null) {
        // No cached or stored result was found: rebuild
        return rebuild(app, NoResultReason(), true)
      }

      // Check for inconsistencies and rebuild when found
      // Internal consistency: output consistency
      run {
        val inconsistencyReason = existingResult.inconsistencyReason
        if (inconsistencyReason != null) {
          return rebuild(app, inconsistencyReason)
        }
      }

      // Internal consistency: generated files
      for (gen in existingResult.gens) {
        val (genPath, stamp) = gen
        val newStamp = stamp.stamper.stamp(genPath)
        if (stamp != newStamp) {
          // If a generated file is outdated (i.e., its stamp changed): rebuild
          return rebuild(app, InconsistentGenPath(existingResult, gen, newStamp))
        }
      }
      // Internal and total consistency: requirements
      for (req in existingResult.reqs) {
        val inconsistencyReason = req.makeConsistent(existingResult, this)
        if (inconsistencyReason != null) {
          return rebuild(app, inconsistencyReason)
        }
      }

      // No inconsistencies found
      // Validate well-formedness of the dependency graph
      validate(existingResult)
      // Cache the result
      consistent[app] = existingResult
      cache[app] = existingResult
      // Reuse existing result
      return BuildInfo(existingResult)
    } finally {
      stack.remove(app)
    }
  }

  // Method is open internal for testability
  open internal fun <I : In, O : Out> rebuild(app: BuildApp<I, O>, reason: BuildReason, useCache: Boolean = false): BuildInfo<I, O> {
    reporter.build(app, reason)
    val result: BuildRes<I, O>
    try {
      result = if (useCache) {
        share.reuseOrCreate(app, { store.produces(it)?.cast<I, O>() }) { this.rebuildInternal(it) }
      } else {
        share.reuseOrCreate(app) { this.rebuildInternal(it) }
      }
    } catch(e: BuildException) {
      reporter.buildFailed(app, reason, e)
      throw e
    }
    reporter.buildSuccess(app, reason, result)
    return BuildInfo(result, reason)
  }

  // Method is open internal for testability
  open internal fun <I : In, O : Out> rebuildInternal(app: BuildApp<I, O>): BuildRes<I, O> {
    val (builderId, input) = app
    val builder = getBuilder<I, O>(builderId)
    val desc = builder.desc(input)
    val context = BuildContextImpl(this, injector)
    val output = builder.build(input, context)
    val result = BuildRes(builderId, desc, input, output, context.reqs, context.gens)

    // Validate well-formedness of the dependency graph
    validate(result)
    // Store and cache the result
    store.setProduces(app, result)
    consistent[app] = result
    cache[app] = result

    return result
  }

  private fun <I : In, O : Out> validate(result: BuildRes<I, O>) {
    for ((path, _) in result.gens) {
      val generatedBy = store.generatedBy(path)
      store.setGeneratedBy(path, result) // Add to store before throwing exceptions
      if (generatedBy != null) {
        val builder = getBuilder<I, O>(result.builderId)
        // CHANGED: builders may describe if certain different build applications may generate the same file.
        @Suppress("UNCHECKED_CAST")
        if (!builder.mayOverlap(result.input, generatedBy.input as I)) {
          throw OverlappingGeneratedPathException("""Overlapping generated path.
  Path:

    $path

  was generated by:

    ${result.desc}

  and:

    ${generatedBy.desc}
""")
        }
      }
      val requiredBy = store.requiredBy(path)
      // CHANGED: it is allowed to generate something required by something on the stack
      if (requiredBy != null && !stack.contains(requiredBy.toApp)) {
        throw HiddenDependencyException("""Hidden dependency.
  Path:

    $path

  was generated by:

    ${result.desc}

  after being previously required by:

    ${requiredBy.desc}
""")
      }
    }

    for ((path, _) in result.reqs.filterIsInstance<PathReq>()) {
      store.setRequiredBy(path, result)
      val generator = store.generatedBy(path)
      // 'path' is required by 'result', and path is generated by 'generator', thus 'result' must (transitively) require 'generator'
      if (generator != null && !hasBuildReq(result, generator)) {
        throw HiddenDependencyException("""Hidden dependency.
  Build:

    ${result.desc}

  requires path:

    $path

  generated by:

    ${generator.desc}

  without a (transitive) build requirement for it
""")
      }
    }
  }

  private fun hasBuildReq(requiree: UBuildRes, generator: UBuildRes): Boolean {
    // TODO: more efficient implementation for figuring out if a result depends on another result?
    val toCheckQueue: Queue<UBuildRes> = LinkedList()
    toCheckQueue.add(requiree)
    while (!toCheckQueue.isEmpty()) {
      val toCheck = toCheckQueue.poll()
      if (toCheck.requires(generator.toApp)) {
        return true
      }
      val reqRequests = toCheck.reqs.filterIsInstance<UBuildReq>().map { it.app }
      val reqResults = mutableListOf<UBuildRes>()
      for (reqRequest in reqRequests) {
        val reqResult = store.produces(reqRequest) ?: error("Cannot get result for app $reqRequest")
        reqResults.add(reqResult)
      }
      toCheckQueue.addAll(reqResults)
    }
    return false
  }

  private fun <I : In, O : Out> getBuilder(id: String): Builder<I, O> {
    @Suppress("UNCHECKED_CAST")
    return (builders[id] ?: error("Builder with identifier '$id' does not exist")) as Builder<I, O>
  }
}