package mb.ceres.impl.store

import mb.ceres.UBuildApp
import mb.ceres.UBuildRes
import mb.log.Logger
import mb.vfs.path.PPath
import org.lmdbjava.Dbi
import org.lmdbjava.DbiFlags
import org.lmdbjava.Env
import org.lmdbjava.Txn
import java.io.*
import java.nio.ByteBuffer
import java.security.MessageDigest
import javax.inject.Inject

typealias EnvB = Env<ByteBuffer>
typealias DbiB = Dbi<ByteBuffer>
typealias TxnB = Txn<ByteBuffer>

class LMDBBuildStoreFactory @Inject constructor(val logger: Logger) {
  fun create(envDir: File, maxDbSize: Int = 1024 * 1024 * 1024, maxReaders: Int = 1024): LMDBBuildStore {
    return LMDBBuildStore(logger.forContext(LMDBBuildStore::class.java), envDir, maxDbSize, maxReaders)
  }
}

class LMDBBuildStore(val logger: Logger, envDir: File, maxDbSize: Int, maxReaders: Int) : BuildStore {
  val env: Env<ByteBuffer>
  val produces: Dbi<ByteBuffer>
  val generatedBy: Dbi<ByteBuffer>
  val requiredBy: Dbi<ByteBuffer>


  init {
    envDir.mkdirs()
    env = Env.create().setMapSize(maxDbSize.toLong()).setMaxReaders(maxReaders).setMaxDbs(3).open(envDir)
    produces = env.openDbi("produces", DbiFlags.MDB_CREATE)
    generatedBy = env.openDbi("generatedBy", DbiFlags.MDB_CREATE)
    requiredBy = env.openDbi("requiredBy", DbiFlags.MDB_CREATE)
  }

  override fun close() {
    env.close()
  }


  override fun readTxn(): BuildStoreReadTxn {
    val txn = env.txnRead()
    return LMDBBuildStoreReadTxn(env, produces, generatedBy, requiredBy, txn, logger)
  }

  override fun writeTxn(): BuildStoreWriteTxn {
    val txn = env.txnWrite()
    return LMDBBuildStoreWriteTxn(env, produces, generatedBy, requiredBy, txn, logger)
  }


  override fun toString(): String {
    return "LMDBBuildStore"
  }
}

open internal class LMDBBuildStoreReadTxn(
  val env: EnvB, val produces: DbiB, val generatedBy: DbiB, val requiredBy: DbiB, val txn: TxnB, val logger: Logger)
  : BuildStoreReadTxn {
  override fun produces(app: UBuildApp): UBuildRes? {
    val keyBytes: ByteBuffer? = serialize(app, true)
    val valBytes: ByteBuffer? = produces.get(txn, keyBytes)
    if (valBytes != null) {
      val result = deserialize<UBuildRes>(valBytes)
      if (result != null) {
        return result
      }
      // Deserialization failed, remove entry
      logger.trace("Cannot get produced value for {}, deserialization failed", app)
      produces.delete(keyBytes!!)
    }
    return null
  }

  override fun generatedBy(path: PPath): UBuildApp? {
    val keyBytes: ByteBuffer? = serialize(path, true)
    val valBytes: ByteBuffer? = generatedBy.get(txn, keyBytes)
    if (valBytes != null) {
      val result = deserialize<UBuildApp>(valBytes)
      if (result != null) {
        return result
      }
      // Deserialization failed, remove entry
      logger.trace("Cannot get generated by value for {}, deserialization failed", path)
      generatedBy.delete(keyBytes!!)
    }
    return null
  }

  override fun requiredBy(path: PPath): UBuildApp? {
    val keyBytes: ByteBuffer? = serialize(path, true)
    val valBytes: ByteBuffer? = requiredBy.get(txn, keyBytes)
    if (valBytes != null) {
      val result = deserialize<UBuildApp>(valBytes)
      if (result != null) {
        return result
      }
      // Deserialization failed, remove entry
      logger.trace("Cannot get required by value for {}, deserialization failed", path)
      requiredBy.delete(keyBytes!!)
    }
    return null
  }

  override fun close() {
    txn.abort()
  }


  protected fun <T> serialize(obj: T, isKey: Boolean = false): ByteBuffer {
    ByteArrayOutputStream().use {
      ObjectOutputStream(it).use {
        it.writeObject(obj)
      }
      // TODO: ObjectOutputStream.toByteArray() copies the bytes: not efficient
      val bytes = it.toByteArray()
      if (isKey && bytes.size > env.maxKeySize) {
        return hash(bytes)
      }
      // TODO: this copies bytes again: not efficient
      val buffer = ByteBuffer.allocateDirect(bytes.size)
      buffer.put(bytes).flip()
      return buffer
    }
  }

  protected fun <T> deserialize(buffer: ByteBuffer): T? {
    ByteBufferBackedInputStream(buffer).use {
      ObjectInputStream(it).use {
        try {
          @Suppress("UNCHECKED_CAST")
          return it.readObject() as T
        } catch (e: ClassNotFoundException) {
          logger.trace("Deserialization failed", e)
          return null
        } catch (e: ObjectStreamException) {
          logger.trace("Deserialization failed", e)
          return null
        } catch (e: IOException) {
          logger.trace("Deserialization failed", e)
          return null
        }
      }
    }
  }

  protected fun hash(bytes: ByteArray): ByteBuffer {
    val digest = MessageDigest.getInstance("SHA-1")
    val digestBytes = digest.digest(bytes)
    // TODO: this copies bytes again: not efficient
    val buffer = ByteBuffer.allocateDirect(digestBytes.size)
    buffer.put(digestBytes).flip()
    return buffer
  }
}

internal class LMDBBuildStoreWriteTxn(
  env: EnvB, produces: DbiB, generatedBy: DbiB, requiredBy: DbiB, txn: TxnB, logger: Logger)
  : BuildStoreWriteTxn, LMDBBuildStoreReadTxn(env, produces, generatedBy, requiredBy, txn, logger) {
  override fun setProduces(app: UBuildApp, res: UBuildRes) {
    val k = serialize(app, true)
    val v = serialize(res)
    produces.put(txn, k, v)
  }

  override fun setGeneratedBy(path: PPath, res: UBuildApp) {
    val k = serialize(path, true)
    val v = serialize(res)
    generatedBy.put(txn, k, v)
  }

  override fun setRequiredBy(path: PPath, res: UBuildApp) {
    val k = serialize(path, true)
    val v = serialize(res)
    requiredBy.put(txn, k, v)
  }

  override fun drop() {
    produces.drop(txn)
    generatedBy.drop(txn)
    requiredBy.drop(txn)
  }

  override fun close() {
    txn.commit()
  }
}

internal class ByteBufferBackedInputStream(private val buf: ByteBuffer) : InputStream() {
  @Throws(IOException::class)
  override fun read(): Int {
    if (!buf.hasRemaining()) {
      return -1
    }
    return buf.get().toInt() and 0xFF
  }

  @Throws(IOException::class)
  override fun read(bytes: ByteArray, offset: Int, length: Int): Int {
    if (!buf.hasRemaining()) {
      return -1
    }

    val minLength = Math.min(length, buf.remaining())
    buf.get(bytes, offset, minLength)
    return minLength
  }
}