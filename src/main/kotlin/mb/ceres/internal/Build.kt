package mb.ceres.internal

import kotlinx.coroutines.experimental.CoroutineStart
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking
import mb.ceres.*
import java.io.Serializable
import java.util.*

data class BuildRes<out I : In, out O : Out>(val builderId: String, val desc: String, val input: I, val output: O, val reqs: List<Req>, val gens: List<Gen>) : Serializable {
  val toApp get() = BuildApp<I, O>(builderId, input)
  fun requires(other: BuildApp<*, *>): Boolean {
    for ((req, _) in reqs.filterIsInstance<BuildReq<*, *>>()) {
      if (other == req) {
        return true
      }
    }
    return false
  }
}
typealias UBuildRes = BuildRes<*, *>

interface Build {
  fun <I : In, O : Out> require(app: BuildApp<I, O>): BuildRes<I, O>
}

open class BuildImpl(private val store: Store, private val builderStore: BuilderStore, private val share: BuildShare) : Build {
  private val isConsistent = mutableSetOf<UBuildApp>()
  private val requireStack = mutableSetOf<UBuildApp>()

  override fun <I : In, O : Out> require(app: BuildApp<I, O>): BuildRes<I, O> {
    try {
      if (requireStack.contains(app)) {
        throw CyclicDependencyException("Cyclic dependency: requirement of $app from requirements ${requireStack.joinToString(" -> ")} creates cycle")
      }
      requireStack.add(app)

      val cachedResult = getCachedResult(app)
      if (cachedResult == null) {
        // No existing result was found: rebuild
        return rebuild(app)
      }

      if (isConsistent.contains(app)) {
        // Existing result is known to be consistent this build: reuse
        return cachedResult
      }

      // Check for inconsistencies and rebuild when found
      // Internal consistency: generated files
      for ((genPath, stamp) in cachedResult.gens) {
        val newStamp = stamp.stamper.stamp(genPath)
        if (stamp != newStamp) {
          // If a generated file is outdated (i.e., its stamp changed): rebuild
          return rebuild(app)
        }
      }
      // Internal and total consistency: requirements
      for (req in cachedResult.reqs) {
        if (!req.makeConsistent(this)) {
          return rebuild(app)
        }
      }

      // No inconsistencies found
      // Validate well-formedness of the dependency graph
      validate(cachedResult)
      // Mark result consistent.
      isConsistent.add(app)
      // Reuse existing result
      return cachedResult
    } finally {
      requireStack.remove(app)
    }
  }

  // Method is open internal for testability
  open internal fun <I : In, O : Out> rebuild(app: BuildApp<I, O>): BuildRes<I, O> {
    @Suppress("UNCHECKED_CAST")
    val result = runBlocking {
      share[app]?.await() as BuildRes<I, O>? ?: try {
        val deferred = async(context, CoroutineStart.LAZY) {
          val (builderId, input) = app
          val builder = builderStore.getBuilder<I, O>(builderId)
          val desc = builder.desc(input)
          println("Executing builder $desc")
          val context = BuildContextImpl(this@BuildImpl)
          val output = builder.build(input, context)
          BuildRes(builderId, desc, input, output, context.reqs, context.gens)
        }
        share[app] = deferred
        deferred.await()
      } finally {
        share.remove(app)
      }
    }

    // Validate well-formedness of the dependency graph
    validate(result)
    // Cache result and mark it consistent
    store.setProduces(app, result)
    isConsistent.add(app)

    return result
  }

  private fun <I : In, O : Out> validate(result: BuildRes<I, O>) {
    for ((path, _) in result.gens) {
      val generatedBy = store.generatedBy(path)
      store.setGeneratedBy(path, result) // Add to store before throwing exceptions
      if (generatedBy != null && generatedBy != result) {
        throw OverlappingGeneratedPathException("Overlapping generated path: $path was generated by '${result.desc}' and '${generatedBy.desc}'")
      }
      val requiredBy = store.requiredBy(path)
      if (requiredBy != null) {
        throw HiddenDependencyException("Hidden dependency: $path was generated by '${result.desc}' after being previously required by ${requiredBy.desc}")
      }
    }

    for ((path, _) in result.reqs.filterIsInstance<PathReq>()) {
      store.setRequiredBy(path, result)
      val generator = store.generatedBy(path)
      // 'path' is required by 'result', and path is generated by 'generator', thus 'result' must (transitively) require 'generator'
      if (generator != null && !hasBuildReq(result, generator)) {
        throw HiddenDependencyException("Hidden dependency: '${result.desc}' requires path $path, generated by '${generator.desc}', without a (transitive) build requirement for it")
      }
    }
  }

  private fun hasBuildReq(requiree: UBuildRes, generator: UBuildRes): Boolean {
    // TODO: more efficient implementation for figuring out if a result depends on another result?
    val toCheckQueue: Queue<UBuildRes> = LinkedList()
    toCheckQueue.add(requiree)
    while (!toCheckQueue.isEmpty()) {
      val toCheck = toCheckQueue.poll()
      if (toCheck.requires(generator.toApp)) {
        return true
      }
      val reqRequests = toCheck.reqs.filterIsInstance<BuildReq<*, *>>().map { it.app }
      val reqResults = mutableListOf<UBuildRes>()
      for (reqRequest in reqRequests) {
        val reqResult = store.produces(reqRequest) ?: error("Cannot get result for app $reqRequest")
        reqResults.add(reqResult)
      }
      toCheckQueue.addAll(reqResults)
    }
    return false
  }

  private fun <I : In, O : Out> getCachedResult(app: BuildApp<I, O>): BuildRes<I, O>? {
    @Suppress("UNCHECKED_CAST")
    return store.produces(app) as BuildRes<I, O>?
  }
}