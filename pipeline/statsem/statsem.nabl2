module statsem

imports

  signatures/-

signature

  namespaces Type Func Var

  name resolution

    labels          P I
    order           D < I, D < P, I < P
    well-formedness P*.I*

rules // Init

  init ^ (s_root) :=
    new s_root,
    
    NullTy() <! NullableTy(BoolTy()),
    BoolTy() <! NullableTy(BoolTy()),
    
    NullTy() <! NullableTy(IntTy()),
    IntTy()  <! NullableTy(IntTy()),
    
    NullTy() <! NullableTy(StrTy()),
    StrTy()  <! NullableTy(StrTy()).

rules // Program

  [[ Program(defs) ^ (s_root) ]] :=
    Map1 [[ defs ^ (s_root) ]],
    distinct/name D(s_root)/Type | error "Duplicate types" @NAMES,
    distinct/name D(s_root)/Func | error "Duplicate functions" @NAMES.

rules // Data definition

  [[ DataDef(DataDefMods(mods), id_type, super, impl) ^ (s) ]] :=
    Type{id_type} <- s,
    Type{id_type}.mods := mods !,
    
    ty == DataTy(Type{id_type}),
    Type{id_type} : ty !,
    NullTy() <! NullableTy(ty),
    ty <! NullableTy(ty),
    [[ super ^ (s, ty) ]],
    
    new s_data,
    s_data -P-> s,
    Type{id_type} =I=> s_data,
    [[ impl ^ (s_data, ty) ]],
    distinct/name D(s_data)/Func | error "Duplicate functions" @NAMES.
  
  [[ NoSuperType() ^ (_, _) ]] := true.
  [[ SuperType(id_type) ^ (s, ty_type_outer) ]] :=
    Type{id_type} -> s,
    Type{id_type} |-> t,
    t : ty,
    ty_type_outer <! ty.

rules // Java data definition implementation

  [[ JDataImpl(id_class_java, membs) ^ (s, ty_type_outer) ]] :=
    ty_type_outer == DataTy(occ_type_outer),
    occ_type_outer.javaClassId := id_class_java !,
    Map1 [[ membs ^ (s) ]].

  [[ JFuncDef(FuncHead(id_func, params_in, params_out)) ^ (s) ]] :=
    Func{id_func} <- s,
    [[ params_in ^ (s) : tys_in ]],
    [[ params_out ^ (s) : tys_out ]],
    ty == FuncTy(tys_in, tys_out),
    Func{id_func} : ty !.

rules // Function definition
  [[ FuncDef(FuncHead(id_func, params_in, params_out), impl) ^ (s) ]] :=
    Func{id_func} <- s,
    new s_func,
    s_func -P-> s,
    [[ params_in ^ (s_func) : tys_in ]],
    new s_func_out,
    s_func_out -P-> s_func,
    [[ params_out ^ (s_func_out) : tys_out ]],
    ty == FuncTy(tys_in, tys_out),
    Func{id_func} : ty !,
    [[ impl ^ (s_func, ty, Func{id_func}) ]],
    distinct/name D(s_func)/Var | error "Duplicate variables" @NAMES.

rules // Java function definition implementation

  [[ JFuncImpl(id_class_java, id_method_java) ^ (s, _, occ_func_outer) ]] := 
    occ_func_outer.javaClassId := id_class_java !,
    occ_func_outer.javaMethodId := id_method_java !.

rules // Pipeline function definition implementation

  [[ FuncImpl(stm) ^ (s, ty_func_outer, _) ]] :=
    [[ stm ^ (s, ty_func_outer) ]].
    
rules // Statements
    
  [[ Block(stms) ^ (s, ty_func_outer) ]] :=
    Map2 [[ stms ^ (s, ty_func_outer) ]].
    
  [[ Assign(params, exp) ^ (s, _) ]] :=
    [[ params ^ (s) : tys_out_expected ]],
    [[ exp ^ (s) : tys_out ]],
    tys_out <? tys_out_expected | error $[Type mismatch, expected [tys_out_expected], got [tys_out]] @ exp.
    
  [[ If(exp, stm) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? BoolTy() | error $[Expected boolean type, got [ty]] @ exp,
    [[ stm ^ (s, ty_func_outer) ]].
    
  [[ Return(exps) ^ (s, ty_func_outer) ]] :=
    [[ exps ^ (s) : tys_ret ]],
    ty_func_outer == FuncTy(_, tys_ret_expected),
    tys_ret <? tys_ret_expected | error $[Type mismatch, expected [tys_ret_expected], got [tys_ret]] @ exps.
    
  [[ Exp(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : _ ]].

rules // Expressions

  [[ t@Eq(exps_l, exps_r) ^ (s) : BoolTy() ]] :=
    [[ exps_l ^ (s) : tys_l ]],
    [[ exps_r ^ (s) : tys_r ]],
    // TODO: should use LUB to work both ways. However, that requires separating nullability into a property 
    // of a type (by creating a tuple for each type), because otherwise LUB could always result into the top 
    // type NullTy(), instead of failing.
    tys_r <? tys_l | error $[Type mismatch, cannot compare [tys_l] to [tys_r]] @ t.
    
  [[ Ref(id_var) ^ (s) : ty ]] :=
    Var{id_var} -> s,
    Var{id_var} |-> v,
    v : ty.
    
  [[ Call(id_func, args) ^ (s) : tys_out ]] :=
    Func{id_func} -> s,
    Func{id_func} |-> f,
    f : FuncTy(tys_in_expected, tys_out),
    [[ args ^ (s) : tys_in ]],
    tys_in <? tys_in_expected | error $[Type mismatch, expected [tys_in_expected], got [tys_in]] @ args.

  [[ QCall(exp, id_func, args) ^ (s) : tys_out ]] :=
    [[ exp ^ (s) : DataTy(occ_data) ]],
    occ_data ?=I=> s_assoc_data,
    new s_imp,
    s_imp -I-> s_assoc_data,
    Func{id_func} -> s_imp,
    Func{id_func} |-> f,
    f : FuncTy(tys_in_expected, tys_out),
    [[ args ^ (s) : tys_in ]], 
    tys_in <? tys_in_expected | error $[Type mismatch, expected [tys_in_expected], got [tys_in]] @ args.
  
  [[ Exps(exps) ^ (s) : tys ]] :=
    Map1T [[ exps ^ (s) : tys ]].
  
  [[ BoolLit(_) ^ (s) : BoolTy() ]] := true.
  [[ IntLit(_)  ^ (s) : IntTy()  ]] := true.
  [[ StrLit(_)  ^ (s) : StrTy()  ]] := true.
  [[ NullLit()  ^ (s) : NullTy() ]] := true.

rules // Params

  [[ Params(params) ^ (s) : tys ]] :=
    Map1T [[ params ^ (s) : tys ]].
    
  [[ Param(ty) ^ (s) : ty_bound ]] :=
    [[ ty ^ (s) : ty_bound ]].
    
  [[ NParam(id_var, ty) ^ (s) : ty_bound ]] :=
     Var{id_var} <- s,
     [[ ty ^ (s) : ty_bound ]],
     Var{id_var} : ty_bound !.

rules // Types

  [[ BoolTy()   ^ (s) : BoolTy() ]] := true.
  [[ IntTy()    ^ (s) : IntTy()  ]] := true.
  [[ StrTy()    ^ (s) : StrTy()  ]] := true.
  [[ NullTy()   ^ (s) : NullTy() ]] := true.
  
  [[ DataTy(id_type) ^ (s) : DataTy(t) ]] :=
    Type{id_type} -> s,
    Type{id_type} |-> t.
  [[ FuncTy(tys_in, tys_out) ^ (s) : FuncTy(tys_in_bound, tys_out_bound) ]] :=
    Map1 [[ tys_in ^ (s) : tys_in_bound ]],
    Map1 [[ tys_out ^ (s) : tys_out_bound ]].

  [[ NullableTy(ty) ^ (s) : NullableTy(ty_bound) ]] :=
    [[ ty ^ (s) : ty_bound ]].
