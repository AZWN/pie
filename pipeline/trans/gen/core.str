module gen/core

imports

  libspoofax/stratego/debug
  nabl2/api 

  signatures/-
  signatures/lex/-
  signatures/impl/-

rules

  p2p:
    Program(defs) -> results
    with
      results := <filter(p2p-def)> defs

rules // definitions

  p2p-def:
    FuncDef(FuncHead(funcId, inParams, outParams), FuncImpl(Block(stms))) -> (className, str)
    with
      className := <p2p-sanitize-class-id> funcId
    with
      inParamsTuples := <p2p-params-tuples> inParams
    ; inputFields    := <p2p-param-tuple-2fields> inParamsTuples
    ; inputParams    := <p2p-param-tuple-2params> inParamsTuples
    ; inputAssigns   := <p2p-param-tuple-2assigns> inParamsTuples
    with
      outParamsTuples    := <p2p-params-tuples> outParams
    ; outputFields       := <p2p-param-tuple-2fields> outParamsTuples
    ; outputParams       := <p2p-param-tuple-2params> outParamsTuples
    ; outputAssigns      := <p2p-param-tuple-2assigns> outParamsTuples
    ; outputHashCodeImpl := <p2p-param-tuple-2hashcodes> outParamsTuples
    ; outputEqualsImpl   := <p2p-param-tuple-2equals> outParamsTuples
    with
      persistentPathImpl := ""
    ; buildImpl := ""
    ; outputImpl := ""
    with
      str := 
$[import java.io.File;
import java.io.IOException;

import javax.annotation.Nullable;

import build.pluto.builder.BuildRequest;
import build.pluto.builder.Builder;
import build.pluto.builder.factory.BuilderFactory;
import build.pluto.dependency.Origin;

public class [className] extends ABuilder<[className].Input, [className].Output> {
    public static class Input extends AInput {
        private static final long serialVersionUID = 1L;

        [inputFields]

        public Input(File depDir, @Nullable Origin origin, [inputParams]) {
            super(depDir, origin);
            [inputAssigns]
        }
    }

    public static class Output implements build.pluto.output.Output {
        private static final long serialVersionUID = 1L;

        [outputFields]

        public Output([outputParams]) {
            [outputAssigns]
        }

        @Override public int hashCode() {
            final int prime = 31;
            int result = 1;
            [outputHashCodeImpl]
            return result;
        }

        @Override public boolean equals(Object obj) {
            if(this == obj)
                return true;
            if(obj == null)
                return false;
            if(getClass() != obj.getClass())
                return false;
            final Output other = (Output) obj;
            [outputEqualsImpl]
            return true;
        }
    }


    public static final BuilderFactory<Input, Output, [className]> factory = factory([className].class, Input.class);

    public static BuildRequest<Input, Output, [className], BuilderFactory<Input, Output, [className]>> request(Input input) {
        return request(input, [className].class, Input.class);
    }

    public static Origin origin(Input input) {
        return origin(input, [className].class, Input.class);
    }

    public static Result<Output> requireBuild(Builder<?, ?> requiree, Input input) throws IOException {
        return requireBuild(requiree, input, [className].class, Input.class);
    }


    public [className](Input input) {
        super(input);
    }


    @Override protected String description(Input input) {
        return "[className]";
    }

    @Override public File persistentPath(Input input) {
        //final String sanitizedInputUri = FileUtils.sanitize(input.inputUri);
        //final String sanitizedOutputUri = FileUtils.sanitize(input.outputUri);
        //return depFile("-" + sanitizedInputUri + "-" + sanitizedOutputUri);
        return depFile("[className]-"[persistentPathImpl]);
    }

    @Override protected Output build(Input input) throws Throwable {
        requireOrigins();

        [buildImpl]

        return new Output([outputImpl]);
    }
}
]
    

rules // statements

  try-p2p-stm = p2p-try-debug(p2p-stm|"p2p-stm")

  p2p-stm = fail

rules 

  try-p2p-exp = p2p-try-debug(p2p-exp|"p2p-exp")

  p2p-exp = fail

rules // types

  p2p-type: BoolTy()             -> "bool"
  p2p-type: NullableTy(BoolTy()) -> "@Nullable Boolean"
  p2p-type: IntTy()              -> "int"
  p2p-type: NullableTy(IntTy())  -> "@Nullable Integer"
  p2p-type: StrTy()              -> "String"
  p2p-type: NullableTy(StrTy())  -> "@Nullable String"
  
  p2p-type:
    DataTy(ty) -> javaClassId
    with
      a           := <nabl2-get-ast-analysis> ty
    ; refOcc      := <nabl2-mk-occurrence(|"Type")> ty
    ; defOcc      := <nabl2-get-resolved-name(|a); Fst> refOcc
    ; javaClassId := <nabl2-get-property(|a, "javaClassId")> defOcc
  
  p2p-type:
    NullableTy(d@DataTy(_)) -> $[@Nullable [javaClassId]]
    with
      javaClassId := <p2p-type> d

rules // parameters

  p2p-params-tuples:
    Params(params) -> paramTuples
    with
      paramTuples := <nmap(p2p-param-tuples|1)> params
    
  p2p-param-tuples(|i):
    Param(ty) -> ($[p[<int-to-string> i]], tyStr)
    with
      tyStr := <p2p-type> ty

  p2p-param-tuples(|i):
    NParam(varId, ty) -> (varId, tyStr)
    with
      tyStr := <p2p-type> ty

  
  p2p-param-tuple-2fields:
    paramTuples -> str
    with
      fieldStrs := <map(\(varId, tyStr) -> $[public final [tyStr] [varId];]\)> paramTuples
    ; str       := <separate-by(|"\n"); concat-strings> fieldStrs

  p2p-param-tuple-2params:
    paramTuples -> str
    with
      paramStrs := <map(\(varId, tyStr) -> $[[tyStr] [varId]]\)> paramTuples
    ; str       := <separate-by(|", "); concat-strings> paramStrs

  p2p-param-tuple-2assigns:
    paramTuples -> str
    with
      assignStrs := <map(\(varId, _) -> $[this.[varId] = [varId];]\)> paramTuples
    ; str        := <separate-by(|"\n"); concat-strings> assignStrs

  p2p-param-tuple-2hashcodes:
    paramTuples -> str
    with
      hashCodeStrs := <map(\(varId, _) -> $[result = prime * result + (([varId] == null) ? 0 : [varId].hashCode());]\)> paramTuples
    ; str          := <separate-by(|"\n"); concat-strings> hashCodeStrs
    
  p2p-param-tuple-2equals:
    paramTuples -> str
    with
      equalsStrs := <map(\(varId, _) -> $[if([varId] == null) { if(other.[varId] != null) return false; } else if(![varId].equals(other.[varId])) return false;]\)> paramTuples
    ; str        := <separate-by(|"\n"); concat-strings> equalsStrs

rules // sanitation

  p2p-sanitize-class-id = string-replace(|"-", "_")

rules // debug

  p2p-try-fail(|n) = debug(|$[Failed to apply [n] to:[" "]])
  p2p-try-debug(s|n) = s <+ (p2p-try-fail(|n); fail)
  p2p-filter-debug(s|n) = filter(s <+ p2p-try-debug(s|n))
