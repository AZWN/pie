module gen/core

imports

  libspoofax/stratego/debug
  nabl2/api

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  statsem

rules

  p2p:
    Program(defs) -> results
    with
      results := <filter(p2p-def)> defs

rules // definitions

  p2p-def:
    FuncDef(FuncHead(funcId, inParams, outParams), FuncImpl(Block(stms))) -> (className, str)
    with
      className := <p2p-sanitize-class-id> funcId
    with
      inParamsTuples := <p2p-params-tuples> inParams
    ; inputFields    := <p2p-param-tuple-2fields> inParamsTuples
    ; inputParams    := <p2p-param-tuple-2params> inParamsTuples
    ; inputAssigns   := <p2p-param-tuple-2constructorassigns> inParamsTuples
    with
      outParamsTuples    := <p2p-params-tuples> outParams
    ; outputFields       := <p2p-param-tuple-2fields> outParamsTuples
    ; outputParams       := <p2p-param-tuple-2params> outParamsTuples
    ; outputAssigns      := <p2p-param-tuple-2constructorassigns> outParamsTuples
    ; outputHashCodeImpl := <p2p-param-tuple-2hashcodes> outParamsTuples
    ; outputEqualsImpl   := <p2p-param-tuple-2equals> outParamsTuples
    with
      persistentPathImpl := <p2p-param-tuples-2persistentpath> inParamsTuples
    with
      buildImpl   := <p2p-stms> stms
    ; emptyReturn := <?[]; !"return new Output();" <+ !""> outParamsTuples
    with
      str := 
$[package org.metaborg.pipeline.generated;

import java.io.File;
import java.io.IOException;

import javax.annotation.Nullable;

import org.apache.commons.vfs2.FileObject;
import org.metaborg.pipeline.util.ABuilder;
import org.metaborg.pipeline.util.AInput;
import org.metaborg.pipeline.util.Result;
import org.metaborg.util.file.FileUtils;

import build.pluto.builder.BuildRequest;
import build.pluto.builder.Builder;
import build.pluto.builder.factory.BuilderFactory;
import build.pluto.dependency.Origin;

public class [className] extends ABuilder<[className].Input, [className].Output> {
    public static class Input extends AInput {
        private static final long serialVersionUID = 1L;

        [inputFields]

        public Input(File depDir, @Nullable Origin origin, [inputParams]) {
            super(depDir, origin);
            [inputAssigns]
        }
    }

    public static class Output implements build.pluto.output.Output {
        private static final long serialVersionUID = 1L;

        [outputFields]

        public Output([outputParams]) {
            [outputAssigns]
        }

        @Override public int hashCode() {
            final int prime = 31;
            int result = 1;
            [outputHashCodeImpl]
            return result;
        }

        @Override public boolean equals(Object obj) {
            if(this == obj)
                return true;
            if(obj == null)
                return false;
            if(getClass() != obj.getClass())
                return false;
            final Output other = (Output) obj;
            [outputEqualsImpl]
            return true;
        }
    }


    public static final BuilderFactory<Input, Output, [className]> factory = factory([className].class, Input.class);

    public static BuildRequest<Input, Output, [className], BuilderFactory<Input, Output, [className]>> request(Input input) {
        return request(input, [className].class, Input.class);
    }

    public static Origin origin(Input input) {
        return origin(input, [className].class, Input.class);
    }

    public static Result<Output> requireBuild(Builder<?, ?> requiree, Input input) throws IOException {
        return requireBuild(requiree, input, [className].class, Input.class);
    }


    public [className](Input input) {
        super(input);
    }


    @Override protected String description(Input input) {
        return "[className]";
    }

    @Override public File persistentPath(Input input) {
        return depFile("[className]", [persistentPathImpl]);
    }

    @Override protected Output build(Input input) throws Throwable {
        requireOrigins();

        Origin origin = input.origin;
        
        [buildImpl]
        [emptyReturn]
    }
}
]
    

rules // statements

  try-p2p-stm    = p2p-try-debug(p2p-stm|"p2p-stm") <+ !""
  p2p-stms       = p2p-stms(|"\n")
  p2p-stms(|sep) = map(try-p2p-stm); separate-by(|sep); concat-strings


  p2p-stm:
    Block(stms) -> 
$[{
    [str]
}]
    with
      str := <p2p-stms> stms

  p2p-stm:
    Assign(params, exp) -> 
$[[initStr]
[assignStr]]
    with
      paramTuples         := <p2p-params-tuples> params
    ; (initStrs, expStrs) := <try-p2p-exp> exp
    ; initStr             := <p2p-sep-nl; concat-strings> initStrs
    ; assignStrs          := <zip(\((varId, tyStr), expStr) -> $[final [tyStr] [varId] = [expStr];]\)> (paramTuples, expStrs)
    ; assignStr           := <p2p-sep-nl; concat-strings> assignStrs

  p2p-stm:
    If(exp, stm) -> 
$[[initStr]
if([expStr])
    [strStm]]
    with
      strStm := <try-p2p-stm> stm
    ; (initStrs, expStrs) := <try-p2p-exp> exp
    ; initStr := <p2p-sep-nl; concat-strings> initStrs
    ; expStr  := <separate-by(|" && "); concat-strings> expStrs

  p2p-stm:
    Return(exp) -> 
$[[initStr]
return new Output([expStr]);]
    with
      (initStrs, expStrs) := <try-p2p-exp> exp
    ; initStr := <p2p-sep-nl; concat-strings> initStrs
    ; expStr  := <p2p-sep-comma; concat-strings> expStrs

  p2p-stm:
    Exp(exp) -> 
$[[initStr]
[expStr]]
    with
      (initStrs, expStrs) := <try-p2p-exp> exp
    ; initStr := <p2p-sep-nl; concat-strings> initStrs
    ; expStr  := <map(\str -> $[eat([str]);]\); p2p-sep-nl; concat-strings> expStrs
  
rules 

  try-p2p-exp = p2p-try-debug(p2p-exp|"p2p-exp") <+ !([], [])
  
  
  p2p-exp:
    Eq(lExp, rExp) -> (allInitStrs, [expStr])
    with
      (lInitStrs, lExpStrs) := <try-p2p-exp> lExp
    ; (rInitStrs, rExpStrs) := <try-p2p-exp> rExp
    ; allInitStrs := <concat> [lInitStrs, rInitStrs]
    ; expStr := <zip(\(lExpStr, rExpStr) -> $[[lExpStr] == [rExpStr]]\); separate-by(|" && "); concat-strings> (lExpStrs, rExpStrs)
  
  
  p2p-exp: 
    Ref('id) -> ([], ['id])
    where
      LocalVarKind() := <p2p-ast-ref-prop(|"Var", "kind")> 'id
  
  p2p-exp: 
    Ref('id) -> ([], [$[input.['id]]])
    where
      InputVarKind() := <p2p-ast-ref-prop(|"Var", "kind")> 'id


  p2p-exp: 
    Call(funcId, exp) -> (initStrs, [$[[javaClassId].[javaMethodId]([expStr])]])
    where
      JavaStaticFuncKind() := <p2p-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId         := <p2p-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; javaMethodId        := <p2p-ast-ref-prop(|"Func", "javaMethodId")> funcId
    ; (initStrs, expStrs) := <try-p2p-exp> exp
    ; expStr              := <p2p-sep-comma; concat-strings> expStrs
  
  p2p-exp:
    c@Call(funcId, _) -> <p2p-exp-pluto-call(|javaClassId)> c
    where
      PlutoBuilderFuncKind() := <p2p-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <p2p-ast-ref-prop(|"Func", "javaClassId")> funcId
    
  p2p-exp: 
    c@Call(funcId, _) -> <p2p-exp-pluto-call(|javaClassId)> c 
    where
      PipelineFuncKind() := <p2p-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <p2p-sanitize-class-id> funcId
  
  p2p-exp-pluto-call(|javaClassId):
   Call(funcId, exp) -> (allInitStrs, outExpStrs)
    with
      (expInitStrs, expStrs) := <try-p2p-exp> exp
    ; expStr                 := <p2p-sep-comma; concat-strings> expStrs
    ; initId                 := <newname> "init"
    ; initStr                := 
$[final Result<[javaClassId].Output> [initId] = [javaClassId].requireBuild(this, new [javaClassId].Input(input.depDir, origin, [expStr]));
origin = Origin.Builder().add(input.origin).add([initId].origin).get();]
    ; allInitStrs            := <concat> [expInitStrs, [initStr]]
    ; outParamsTuples        := <p2p-ast-ref-prop(|"Func", "outParams"); p2p-params-tuples> funcId
    ; outExpStrs             := <map(\(varId, _) -> $[[initId].output.[varId]]\)> outParamsTuples
    
  p2p-exp: 
    QCall(exp, funcId, argsExp) -> (allInitStrs, [$[[expStr].[funcId]([argsExpStr])]])
    with
      (initStrs, expStrs)         := <try-p2p-exp> exp
    ; expStr                      := <Hd> expStrs // HACK: assuming single return type
    ; (argsInitStrs, argsExpStrs) := <try-p2p-exp> argsExp
    ; argsExpStr                  := <p2p-sep-comma; concat-strings> argsExpStrs
    ; allInitStrs := <concat> [initStrs, argsInitStrs]

  
  p2p-exp: Exps(exps) -> <map(try-p2p-exp); unzip; (concat, concat)> exps

  
  p2p-exp: BoolLit(True())  -> ([], [$[true]])
  p2p-exp: BoolLit(False()) -> ([], [$[false]])
  p2p-exp: IntLit(i)        -> ([], [i])
  p2p-exp: StrLit(str)      -> ([], [str])
  p2p-exp: NullLit()        -> ([], [$[null]])
  
rules // types

  p2p-type: BoolTy()             -> "bool"
  p2p-type: NullableTy(BoolTy()) -> "@Nullable Boolean"
  p2p-type: IntTy()              -> "int"
  p2p-type: NullableTy(IntTy())  -> "@Nullable Integer"
  p2p-type: StrTy()              -> "String"
  p2p-type: NullableTy(StrTy())  -> "@Nullable String"
  
  p2p-type:
    DataTy(ty) -> javaClassId
    where
      JavaTypeKind() := <p2p-ast-ref-prop(|"Type", "kind")> ty
    with  
      javaClassId := <p2p-ast-ref-prop(|"Type", "javaClassId")> ty
  
  p2p-type:
    NullableTy(DataTy(ty)) -> $[@Nullable [javaClassId]]
    where
      JavaTypeKind() := <p2p-ast-ref-prop(|"Type", "kind")> ty
    with  
      javaClassId := <p2p-ast-ref-prop(|"Type", "javaClassId")> ty

rules // parameters

  p2p-params-tuples:
    Params(params) -> paramTuples
    with
      paramTuples := <nmap(p2p-param-tuple|1)> params
    
  p2p-param-tuple(|i):
    Param(ty) -> ($[p[<int-to-string> i]], tyStr)
    with
      tyStr := <p2p-type> ty

  p2p-param-tuple(|i):
    NParam(varId, ty) -> (varId, tyStr)
    with
      tyStr := <p2p-type> ty

  
  p2p-param-tuple-2fields:
    paramTuples -> str
    with
      fieldStrs := <map(\(varId, tyStr) -> $[public final [tyStr] [varId];]\)> paramTuples
    ; str       := <p2p-sep-nl; concat-strings> fieldStrs

  p2p-param-tuple-2params:
    paramTuples -> str
    with
      paramStrs := <map(\(varId, tyStr) -> $[[tyStr] [varId]]\)> paramTuples
    ; str       := <p2p-sep-comma; concat-strings> paramStrs

  p2p-param-tuple-2constructorassigns:
    paramTuples -> str
    with
      assignStrs := <map(\(varId, _) -> $[this.[varId] = [varId];]\)> paramTuples
    ; str        := <p2p-sep-nl; concat-strings> assignStrs

  p2p-param-tuple-2hashcodes:
    paramTuples -> str
    with
      hashCodeStrs := <map(\(varId, _) -> $[result = prime * result + (([varId] == null) ? 0 : [varId].hashCode());]\)> paramTuples
    ; str          := <p2p-sep-nl; concat-strings> hashCodeStrs
    
  p2p-param-tuple-2equals:
    paramTuples -> str
    with
      equalsStrs := <map(\(varId, _) -> $[if([varId] == null) { if(other.[varId] != null) return false; } else if(![varId].equals(other.[varId])) return false;]\)> paramTuples
    ; str        := <p2p-sep-nl; concat-strings> equalsStrs

  p2p-param-tuples-2persistentpath:
    paramTuples -> str
    where
      <not(?[])> paramTuples
    with
      stringStrs := <map(\(varId, _) -> $[input.[varId]]\)> paramTuples
    ; str        := <p2p-sep-comma; concat-strings> stringStrs

rules // sanitation

  p2p-sanitize-class-id = string-replace(|"-", "_")

rules // util

  p2p-ast-ref-resolve(|ns):
    term -> defOcc
    with
      a      := <nabl2-get-ast-analysis> term
    ; refOcc := <nabl2-mk-occurrence(|ns)> term
    ; defOcc := <nabl2-get-resolved-name(|a); Fst> refOcc
    
  p2p-ast-ref-prop(|ns, prop):
    term -> val
    with
      defOcc := <p2p-ast-ref-resolve(|ns)> term
    ; a      := <nabl2-get-ast-analysis> term
    ; val    := <nabl2-get-property(|a, prop)> defOcc
    
  p2p-sep-nl    = separate-by(|"\n")
  p2p-sep-comma = separate-by(|", ")
    
rules // debug

  p2p-try-fail(|n) = debug(|$[Failed to apply [n] to:[" "]])
  p2p-try-debug(s|n) = s <+ (p2p-try-fail(|n); fail)
  p2p-filter-debug(s|n) = filter(s <+ p2p-try-debug(s|n))
