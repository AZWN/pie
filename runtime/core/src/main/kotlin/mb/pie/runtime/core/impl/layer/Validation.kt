package mb.pie.runtime.core.impl.layer

import com.google.inject.Inject
import mb.log.Logger
import mb.pie.runtime.core.*
import mb.pie.runtime.core.impl.*
import java.io.*
import java.util.*


class ValidationLayer @Inject constructor(logger: Logger) : Layer {
  data class Options(
    var cycle: Boolean = true,
    var overlappingGenPath: Boolean = true,
    var genAfterReq: Boolean = true,
    var reqWithoutGenDep: Boolean = true,

    var inputObject: Boolean = false,
    var outputObject: Boolean = false,

    var throwErrors: Boolean = true,
    var throwWarnings: Boolean = false
  )

  var options = Options()

  private val logger = logger.forContext(javaClass)
  private val stack = mutableSetOf<UFuncApp>()


  override fun <I : In, O : Out> requireStart(app: FuncApp<I, O>) {
    if(stack.contains(app)) {
      error("""Cyclic dependency. Cause:
        |requirement of
        |  $app
        |from requirements
        |  ${stack.joinToString(" -> ")}
        |""".trimMargin())
    }
    stack.add(app)

    if(options.inputObject) {
      validateInput(app)
    }
  }

  override fun <I : In, O : Out> requireEnd(app: FuncApp<I, O>) {
    stack.remove(app)
  }

  override fun <I : In, O : Out> validate(app: FuncApp<I, O>, result: ExecRes<I, O>, funcs: Funcs, readTnx: StoreReadTxn) {
    for((path, _) in result.gens) {
      val generatedBy = readTnx.generatedBy(path)
      if(generatedBy != null) {
        val func = funcs.getFunc<I, O>(result.id)
        // CHANGED: builders may describe if certain different build applications may generate the same file.
        @Suppress("UNCHECKED_CAST")
        if(!func.mayOverlap(result.input, generatedBy.input as I)) {
          error("""Overlapping generated path. Cause:
              |path
              |  $path
              |was generated by
              |  ${result.desc}
              |and
              |  $generatedBy
              |""".trimMargin())
        }
      }

        // CHANGED: 'path' is generated by 'result', and path is required by 'requiredBy', thus 'requiredBy' must (transitively) require 'app'.
      val requiredByApps = readTnx.requiredBy(path)
      for(requiredBy in requiredByApps) {
        // CHANGED: it is allowed to generate something required by something on the stack.
        if(stack.contains(requiredBy)) {
          val requiredByResult = readTnx.resultsIn(requiredBy)
          if(requiredByResult != null && !hasBuildReq(requiredByResult, app, readTnx, funcs)) {
            error("""Hidden dependency. Cause:
              |path
              |  $path
              |was generated by
              |  ${result.desc}
              |after being previously required by
              |  $requiredBy
              |""".trimMargin())
          }
        }
      }
    }

    for((path, _) in result.reqs.filterIsInstance<PathReq>()) {
      val generator = readTnx.generatedBy(path)
      // 'path' is required by 'result', and path is generated by 'generator', thus 'result' must (transitively) require 'generator'.
      if(generator != null && !hasBuildReq(result, generator, readTnx, funcs)) {
        error("""Hidden dependency. Cause:
            |build
            |  ${result.desc}
            |requires path
            |  $path
            |generated by
            |  $generator
            |without a (transitive) build requirement for it
            |""".trimMargin())
      }
    }

    if(options.outputObject) {
      validateOutput(result)
    }
  }

  private fun hasBuildReq(requiree: UExecRes, generator: UFuncApp, txn: StoreReadTxn, funcs: Funcs): Boolean {
    // TODO: more efficient implementation for figuring out if a result depends on another result?
    val toCheckQueue: Queue<UExecRes> = LinkedList()
    toCheckQueue.add(requiree)
    while(!toCheckQueue.isEmpty()) {
      val toCheck = toCheckQueue.poll()
      if(toCheck.requires(generator, funcs)) {
        return true
      }
      val reqRequests = toCheck.reqs.filterIsInstance<UExecReq>().map { it.app }
      val reqResults = mutableListOf<UExecRes>()
      for(reqRequest in reqRequests) {
        val reqResult = txn.resultsIn(reqRequest) ?: kotlin.error("Cannot get result for app $reqRequest")
        reqResults.add(reqResult)
      }
      toCheckQueue.addAll(reqResults)
    }
    return false
  }

  private fun <I : In, O : Out> validateInput(app: FuncApp<I, O>) {
    val input = app.input ?: return
    val errors = validateObject(input)
    if(errors.isNotEmpty()) {
      val errorsStr = errors
        .mapIndexed { i, msg -> "$i) $msg" }
        .joinToString("\n\n")
      val message = """Input of build application:
        |  $app
        |failed one or more validation checks:
        |
        |$errorsStr
      """.trimMargin()
      warn(message)
    }
  }

  private fun <I : In, O : Out> validateOutput(result: ExecRes<I, O>) {
    val output = result.output ?: return
    val errors =
      if(output is OutTransientEquatableImpl<*, *>) {
        validateObject(output.e ?: return)
      } else {
        validateObject(output)
      }
    if(errors.isNotEmpty()) {
      val errorsStr = errors
        .mapIndexed { i, msg -> "$i) $msg" }
        .joinToString("\n\n")
      val message = """Output of build result:
        |  $result
        |failed one or more validation checks:
        |
        |$errorsStr
      """.trimMargin()
      warn(message)
    }
  }

  private fun validateObject(obj: Serializable): List<String> {
    val errors = mutableListOf<String>()
    val serializedBeforeCalls = serialize(obj)
    val serializedBeforeCallsAgain = serialize(obj)
    if(obj != obj) {
      errors.add("""Not equal to itself.
        |Possible cause: incorrect equals implementation.""".trimMargin())
    }
    run {
      val hash1 = obj.hashCode()
      val hash2 = obj.hashCode()
      if(hash1 != hash2) {
        errors.add("""Produced different hash codes.
          |  Possible cause: incorrect hashCode implementation.
          |  Hashes:
          |    $hash1
          |  vs
          |    $hash2""".trimMargin())
      }
    }
    val serializedAfterCalls = serialize(obj)
    val serializedAfterCallsAgain = serialize(obj)
    if(!Arrays.equals(serializedBeforeCalls, serializedBeforeCallsAgain)) {
      errors.add("""Serialized representation is different when serialized twice.
        |  Possible cause: incorrect serialization implementation.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedAfterCalls""".trimMargin())
    } else if(!Arrays.equals(serializedBeforeCalls, serializedAfterCalls)) {
      errors.add("""Serialized representation is different when serialized twice, with calls to equals and hashCode in between.
        |  Possible cause: incorrect serialization implementation, possibly by using a non-transient hashCode cache.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedAfterCalls""".trimMargin())
    } else if(!Arrays.equals(serializedAfterCalls, serializedAfterCallsAgain)) {
      errors.add("""Serialized representation is different when serialized twice, after calls to equals and hashcode.
        |  Possible cause: incorrect serialization implementation.
        |  Serialized bytes:
        |    $serializedAfterCalls
        |  vs
        |    $serializedAfterCallsAgain""".trimMargin())
    }

    val objDeserializedBeforeCalls = deserialize<Serializable>(serializedBeforeCalls)
    val objDeserializedAfterCalls = deserialize<Serializable>(serializedAfterCalls)
    if(obj != objDeserializedBeforeCalls || objDeserializedBeforeCalls != obj) {
      errors.add("""Not equal to itself after deserialization.
        |  Possible cause: incorrect serialization or equals implementation.
        |  Objects:
        |    $obj
        |  vs
        |    $objDeserializedBeforeCalls""".trimMargin())
    } else if(obj != objDeserializedAfterCalls || objDeserializedAfterCalls != obj) {
      errors.add("""Not equal to itself after deserialization, when serialized with calls to equals and hashCode in between.
        |  Possible cause: incorrect serialization or equals implementation, possibly by using a non-transient hashCode cache.
        |  Objects:
        |    $obj
        |  vs
        |    $objDeserializedAfterCalls""".trimMargin())
    }
    run {
      val beforeHash1 = obj.hashCode()
      val beforeHash2 = objDeserializedBeforeCalls.hashCode()
      if(beforeHash1 != beforeHash2) {
        errors.add("""Produced different hash codes after deserialization.
          |  Possible cause: incorrect serialization or hashCode implementation.
          |  Hashes:
          |    $beforeHash1
          |  vs
          |    $beforeHash2""".trimMargin())
      } else {
        val afterHash1 = obj.hashCode()
        val afterHash2 = objDeserializedAfterCalls.hashCode()
        if(afterHash1 != afterHash2) {
          errors.add("""Produced different hash codes after deserialization, when serialized with calls to equals and hashCode in between.
            |  Possible cause: incorrect serialization or hashCode implementation.
            |  Hashes:
            |    $afterHash1
            |  vs
            |    $afterHash2""".trimMargin())
        } else {
        }
      }
    }

    val serializedBeforeCallsTwice = serialize(objDeserializedBeforeCalls)
    val serializedAfterCallsTwice = serialize(objDeserializedAfterCalls)
    if(!Arrays.equals(serializedBeforeCalls, serializedBeforeCallsTwice)) {
      errors.add("""Serialized representation is different after round-trip serialization.
        |  Possible cause: incorrect serialization implementation.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedBeforeCallsTwice""".trimMargin())
    } else if(!Arrays.equals(serializedAfterCalls, serializedAfterCallsTwice)) {
      errors.add("""Serialized representation is different after round-trip serialization, with calls to equals and hashCode in between.
        |  Possible cause: incorrect serialization implementation, possibly by using a non-transient hashCode cache.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedBeforeCallsTwice""".trimMargin())
    }

    return errors
  }

  @Throws(IOException::class)
  private fun serialize(obj: Serializable): ByteArray {
    ByteArrayOutputStream().use({ outputStream ->
      ObjectOutputStream(outputStream).use { objectOutputStream ->
        objectOutputStream.writeObject(obj)
        objectOutputStream.flush()
        return outputStream.toByteArray()
      }
    })
  }

  @Throws(ClassNotFoundException::class, IOException::class)
  private fun <T : Serializable> deserialize(bytes: ByteArray): T {
    ByteArrayInputStream(bytes).use { inputStream ->
      ObjectInputStream(inputStream).use { objectInputStream ->
        @Suppress("UNCHECKED_CAST")
        return objectInputStream.readObject() as T
      }
    }
  }


  private fun error(message: String, exception: Exception? = null) {
    if(options.throwErrors) {
      throw ValidationException(message, exception)
    } else {
      logger.error(message, exception)
    }
  }

  private fun warn(message: String, exception: Exception? = null) {
    if(options.throwWarnings) {
      throw ValidationException(message, exception)
    } else {
      logger.warn(message, exception)
    }
  }
}

class ValidationException(message: String, cause: Throwable? = null) : RuntimeException(message, cause)
