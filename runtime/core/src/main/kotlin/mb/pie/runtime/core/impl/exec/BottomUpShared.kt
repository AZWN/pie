package mb.pie.runtime.core.impl.exec

import mb.pie.runtime.core.*
import mb.vfs.path.PPath
import java.util.*

fun directlyAffectedApps(changedPaths: Collection<PPath>, txn: StoreReadTxn, logger: Logger): HashSet<UFuncApp> {
  val directlyAffected = HashSet<UFuncApp>()
  if(changedPaths.isEmpty()) return directlyAffected;

  // Find function applications that are directly affected by changed paths.
  logger.trace("Affected function applications")
  for(changedPath in changedPaths) {
    logger.trace("  changed: $changedPath")
    // Check function applications that require the changed path.
    val requireeApps = txn.requireesOf(changedPath)
    for(requireeApp in requireeApps) {
      logger.trace("  required by: ${requireeApp.toShortString(200)}")
      if(!txn.pathReqs(requireeApp).filter { it.path == changedPath }.all { it.isConsistent() }) {
        directlyAffected.add(requireeApp)
      }
    }
    // Check function applications that generate the changed path.
    val generatorApp = txn.generatorOf(changedPath)
    if(generatorApp != null) {
      logger.trace("  generated by: ${generatorApp.toShortString(200)}")
      if(!txn.pathGens(generatorApp).filter { it.path == changedPath }.all { it.isConsistent() }) {
        directlyAffected.add(generatorApp)
      }
    }
  }
  return directlyAffected
}

fun dirtyFlaggingAndPropagation(changedPaths: Collection<PPath>, txn: StoreWriteTxn, logger: Logger) {
  val directlyAffected = directlyAffectedApps(changedPaths, txn, logger)
  logger.trace("Dirty flagging and propagation")
  val todo = ArrayDeque(directlyAffected)
  val seen = HashSet<UFuncApp>()
  while(!todo.isEmpty()) {
    val app = todo.pop()
    if(!seen.contains(app)) {
      logger.trace("  dirty: ${app.toShortString(200)}")
      // Optimisation: check if app was already dirty flagged. Don't do transitive flagging if so. Be sure to add to seen.
      txn.setDirty(app, true)
      seen.add(app)
      val calledBy = txn.callersOf(app)
      calledBy.forEach { logger.trace("  called by: ${it.toShortString(200)}") }
      todo += calledBy
    }
  }
}

class DirtyFlaggedReason : ExecReason {
  override fun toString() = "flagged dirty"


  override fun equals(other: Any?): Boolean {
    if(this === other) return true
    if(other?.javaClass != javaClass) return false
    return true
  }

  override fun hashCode(): Int {
    return 0
  }
}
