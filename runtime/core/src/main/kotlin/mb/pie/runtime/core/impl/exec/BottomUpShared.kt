package mb.pie.runtime.core.impl.exec

import mb.pie.runtime.core.*
import mb.vfs.path.PPath
import java.util.*


fun directlyAffectedApps(changedPaths: Collection<PPath>, txn: StoreReadTxn, logger: Logger): HashSet<UFuncApp> {
  val directlyAffected = HashSet<UFuncApp>()
  if(changedPaths.isEmpty()) return directlyAffected
  for(changedPath in changedPaths) {
    logger.trace("* file: $changedPath")
    // Check function applications that require the changed path.
    val requireeApps = txn.requireesOf(changedPath)
    for(requireeApp in requireeApps) {
      logger.trace("  * required by: ${requireeApp.toShortString(200)}")
      if(!txn.pathReqs(requireeApp).filter { it.path == changedPath }.all { it.isConsistent() }) {
        directlyAffected.add(requireeApp)
      }
    }
    // Check function applications that generate the changed path.
    val generatorApp = txn.generatorOf(changedPath)
    if(generatorApp != null) {
      logger.trace("  * generated by: ${generatorApp.toShortString(200)}")
      if(!txn.pathGens(generatorApp).filter { it.path == changedPath }.all { it.isConsistent() }) {
        directlyAffected.add(generatorApp)
      }
    }
  }
  return directlyAffected
}

fun hasCallReq(caller: UFuncApp, callee: UFuncApp, txn: StoreReadTxn): Boolean {
  // TODO: more efficient implementation for figuring out if an app transitively calls on another app?
  val toCheckQueue: Queue<UFuncApp> = LinkedList()
  toCheckQueue.add(caller)
  while(!toCheckQueue.isEmpty()) {
    val toCheck = toCheckQueue.poll()
    val callReqs = txn.callReqs(toCheck);
    if(callReqs.any { it.calleeEqual(callee) }) {
      return true
    }
    toCheckQueue.addAll(callReqs.map { it.callee })
  }
  return false
}

class InvalidatedExecReason : ExecReason {
  override fun toString() = "invalidated"


  override fun equals(other: Any?): Boolean {
    if(this === other) return true
    if(other?.javaClass != javaClass) return false
    return true
  }

  override fun hashCode(): Int {
    return 0
  }
}
