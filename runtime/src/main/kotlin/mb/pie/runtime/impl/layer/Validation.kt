package mb.pie.runtime.impl.layer

import com.google.inject.Inject
import mb.log.Logger
import mb.pie.runtime.*
import mb.pie.runtime.impl.exec.hasCallReq
import java.io.*
import java.util.*


class ValidationLayer @Inject constructor(logger: Logger) : Layer {
  data class Options(
    var cycle: Boolean = true,
    var overlappingGenPath: Boolean = true,
    var genAfterReq: Boolean = true,
    var reqWithoutGenDep: Boolean = true,

    var inputObject: Boolean = false,
    var outputObject: Boolean = false,

    var throwErrors: Boolean = true,
    var throwWarnings: Boolean = false
  )

  var options = Options()

  private val logger = logger.forContext(javaClass)
  private val stack = mutableSetOf<UTask>()


  override fun <I : In, O : Out> requireTopDownStart(task: Task<I, O>) {
    if(stack.contains(task)) {
      error("""Cyclic dependency. Cause:
        |requirement of
        |  $task
        |from requirements
        |  ${stack.joinToString(" -> ")}
        |""".trimMargin())
    }
    stack.add(task)

    if(options.inputObject) {
      validateInput(task)
    }
  }

  override fun <I : In, O : Out> requireTopDownEnd(task: Task<I, O>) {
    stack.remove(task)
  }

  override fun <I : In, O : Out> validatePreWrite(task: Task<I, O>, data: TaskData<O>, txn: StoreReadTxn) {
    for((path, _) in data.fileGens) {
      val generator = txn.generatorOf(path)
      if(generator != null && generator != task) {
        // Overlapping generated file for `file`.
        error("""Overlapping generated file. Cause:
          |file
          |  $path
          |was generated by
          |  $task
          |and
          |  $generator
          |""".trimMargin())
      }
    }
  }

  override fun <I : In, O : Out> validatePostWrite(task: Task<I, O>, data: TaskData<O>, txn: StoreReadTxn) {
    for((path, _) in data.fileReqs) {
      val generator = txn.generatorOf(path)
      when {
        generator == null -> {
          // No generator for `file`.
        }
        task == generator -> {
          // Required `file` generated by itself (`task`).
        }
        !hasCallReq(task, generator, txn) -> {
          // `file` is required by `task`, and `file` is generated by `generator`, thus `task` must (transitively) require `generator`.
          error("""Hidden dependency. Cause:
            |build
            |  $task
            |requires file
            |  $path
            |generated by
            |  $generator
            |without a (transitive) build requirement for it
            |""".trimMargin())
        }
      }
    }

    for((path, _) in data.fileGens) {
      // 'file' is generated by 'result', and file is required by 'requiredBy', thus 'requiredBy' must (transitively) require 'task'.
      val requiredByApps = txn.requireesOf(path)
      for(requiredBy in requiredByApps) {
        when {
          task == requiredBy -> {
            // Required `file` generated by itself (`task`).
          }
          !hasCallReq(requiredBy, task, txn) -> {
            error("""Hidden dependency. Cause:
              |file
              |  $path
              |was generated by
              |  $task
              |after being previously required by
              |  $requiredBy
              |""".trimMargin())
          }
        }
      }
    }

    if(options.outputObject) {
      validateOutput(data.output)
    }
  }

  private fun <I : In, O : Out> validateInput(app: Task<I, O>) {
    val input = app.input
    val errors = validateObject(input)
    if(errors.isNotEmpty()) {
      val errorsStr = errors
        .mapIndexed { i, msg -> "$i) $msg" }
        .joinToString("\n\n")
      val message = """Input of build application:
        |  $app
        |failed one or more validation checks:
        |
        |$errorsStr
      """.trimMargin()
      warn(message)
    }
  }

  private fun <O : Out> validateOutput(output: O) {
    val errors =
      if(output is OutTransientEquatableImpl<*, *>) {
        validateObject(output.e)
      } else {
        validateObject(output)
      }
    if(errors.isNotEmpty()) {
      val errorsStr = errors
        .mapIndexed { i, msg -> "$i) $msg" }
        .joinToString("\n\n")
      val message = """Output of build result:
        |  $output
        |failed one or more validation checks:
        |
        |$errorsStr
      """.trimMargin()
      warn(message)
    }
  }

  private fun validateObject(obj: Serializable?): List<String> {
    val errors = mutableListOf<String>()
    if(obj == null) {
      return errors
    }
    val serializedBeforeCalls = serialize(obj)
    val serializedBeforeCallsAgain = serialize(obj)
    if(obj != obj) {
      errors.add("""Not equal to itself.
        |Possible cause: incorrect equals implementation.""".trimMargin())
    }
    run {
      val hash1 = obj.hashCode()
      val hash2 = obj.hashCode()
      if(hash1 != hash2) {
        errors.add("""Produced different hash codes.
          |  Possible cause: incorrect hashCode implementation.
          |  Hashes:
          |    $hash1
          |  vs
          |    $hash2""".trimMargin())
      }
    }
    val serializedAfterCalls = serialize(obj)
    val serializedAfterCallsAgain = serialize(obj)
    if(!Arrays.equals(serializedBeforeCalls, serializedBeforeCallsAgain)) {
      errors.add("""Serialized representation is different when serialized twice.
        |  Possible cause: incorrect serialization implementation.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedAfterCalls""".trimMargin())
    } else if(!Arrays.equals(serializedBeforeCalls, serializedAfterCalls)) {
      errors.add("""Serialized representation is different when serialized twice, with calls to equals and hashCode in between.
        |  Possible cause: incorrect serialization implementation, possibly by using a non-transient hashCode cache.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedAfterCalls""".trimMargin())
    } else if(!Arrays.equals(serializedAfterCalls, serializedAfterCallsAgain)) {
      errors.add("""Serialized representation is different when serialized twice, after calls to equals and hashcode.
        |  Possible cause: incorrect serialization implementation.
        |  Serialized bytes:
        |    $serializedAfterCalls
        |  vs
        |    $serializedAfterCallsAgain""".trimMargin())
    }

    val objDeserializedBeforeCalls = deserialize<Serializable>(serializedBeforeCalls)
    val objDeserializedAfterCalls = deserialize<Serializable>(serializedAfterCalls)
    if(obj != objDeserializedBeforeCalls || objDeserializedBeforeCalls != obj) {
      errors.add("""Not equal to itself after deserialization.
        |  Possible cause: incorrect serialization or equals implementation.
        |  Objects:
        |    $obj
        |  vs
        |    $objDeserializedBeforeCalls""".trimMargin())
    } else if(obj != objDeserializedAfterCalls || objDeserializedAfterCalls != obj) {
      errors.add("""Not equal to itself after deserialization, when serialized with calls to equals and hashCode in between.
        |  Possible cause: incorrect serialization or equals implementation, possibly by using a non-transient hashCode cache.
        |  Objects:
        |    $obj
        |  vs
        |    $objDeserializedAfterCalls""".trimMargin())
    }
    run {
      val beforeHash1 = obj.hashCode()
      val beforeHash2 = objDeserializedBeforeCalls.hashCode()
      if(beforeHash1 != beforeHash2) {
        errors.add("""Produced different hash codes after deserialization.
          |  Possible cause: incorrect serialization or hashCode implementation.
          |  Hashes:
          |    $beforeHash1
          |  vs
          |    $beforeHash2""".trimMargin())
      } else {
        val afterHash1 = obj.hashCode()
        val afterHash2 = objDeserializedAfterCalls.hashCode()
        if(afterHash1 != afterHash2) {
          errors.add("""Produced different hash codes after deserialization, when serialized with calls to equals and hashCode in between.
            |  Possible cause: incorrect serialization or hashCode implementation.
            |  Hashes:
            |    $afterHash1
            |  vs
            |    $afterHash2""".trimMargin())
        } else {
        }
      }
    }

    val serializedBeforeCallsTwice = serialize(objDeserializedBeforeCalls)
    val serializedAfterCallsTwice = serialize(objDeserializedAfterCalls)
    if(!Arrays.equals(serializedBeforeCalls, serializedBeforeCallsTwice)) {
      errors.add("""Serialized representation is different after round-trip serialization.
        |  Possible cause: incorrect serialization implementation.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedBeforeCallsTwice""".trimMargin())
    } else if(!Arrays.equals(serializedAfterCalls, serializedAfterCallsTwice)) {
      errors.add("""Serialized representation is different after round-trip serialization, with calls to equals and hashCode in between.
        |  Possible cause: incorrect serialization implementation, possibly by using a non-transient hashCode cache.
        |  Serialized bytes:
        |    $serializedBeforeCalls
        |  vs
        |    $serializedBeforeCallsTwice""".trimMargin())
    }

    return errors
  }

  @Throws(IOException::class)
  private fun serialize(obj: Serializable): ByteArray {
    ByteArrayOutputStream().use({ outputStream ->
      ObjectOutputStream(outputStream).use { objectOutputStream ->
        objectOutputStream.writeObject(obj)
        objectOutputStream.flush()
        return outputStream.toByteArray()
      }
    })
  }

  @Throws(ClassNotFoundException::class, IOException::class)
  private fun <T : Serializable> deserialize(bytes: ByteArray): T {
    ByteArrayInputStream(bytes).use { inputStream ->
      ObjectInputStream(inputStream).use { objectInputStream ->
        @Suppress("UNCHECKED_CAST")
        return objectInputStream.readObject() as T
      }
    }
  }


  private fun error(message: String, exception: Exception? = null) {
    if(options.throwErrors) {
      throw ValidationException(message, exception)
    } else {
      logger.error(message, exception)
    }
  }

  private fun warn(message: String, exception: Exception? = null) {
    if(options.throwWarnings) {
      throw ValidationException(message, exception)
    } else {
      logger.warn(message, exception)
    }
  }
}

class ValidationException(message: String, cause: Throwable? = null) : RuntimeException(message, cause)
