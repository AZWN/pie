/// Data that Spoofax expects from a language
data Message = foreign java mb.pipe.run.core.model.message.Msg {}
data Ast = foreign java org.spoofax.interpreter.terms.IStrategoTerm {}
data Token = foreign java mb.pipe.run.core.model.parse.Token {}
data Styling = foreign java mb.pipe.run.core.model.style.Styling {}

/// Library with functions to build SDF3 and ESV specifications
data ParseTable = foreign java mb.pipe.run.spoofax.sdf.Table {}
func sdf2table(specDir: path, mainFile: path, includedFiles: path*) -> ParseTable? = foreign mb.pipe.run.ceres.spoofax.GenerateTable
func jsglrParse(text: string, startSymbol: string, pt: ParseTable) -> (Ast?, Token*?, Message*) = foreign mb.pipe.run.ceres.spoofax.Parse

data SyntaxStyler = foreign java mb.pipe.run.spoofax.esv.StylingRules {}
func esv2styler(mainFile: path, includedFiles: path*) -> SyntaxStyler? = foreign mb.pipe.run.ceres.spoofax.GenerateStylerRules
func esvStyle(tokenStream: Token*, st: SyntaxStyler) -> Styling = foreign mb.pipe.run.ceres.spoofax.Style

/// Language specification configuration
data LangSpecConfig = foreign java mb.pipe.run.spoofax.cfg.LangSpecConfig {
  func extensions() -> string*
  func getName() -> string?
  func getSyntaxMainFile() -> path?
  func getSyntaxStartSymbol() -> string?
  func getSyntaxBasedStylingFile() -> path?
}

/// Combined configuration for the entire workspace
data WorkspaceConfig = foreign java mb.pipe.run.spoofax.cfg.WorkspaceConfig {
  func extensions() -> string*
  func langSpecConfigForExt(extension: string) -> LangSpecConfig?
}
func langSpecConfigForPath(workspace: WorkspaceConfig, path: path) -> LangSpecConfig? = {
  val extension = path.extension();
  if(extension == null) return null;
  return workspace.langSpecConfigForExt(extension!);
}
func generateWorkspaceConfig(text: string, workspaceRoot: path) -> WorkspaceConfig? = foreign mb.pipe.run.ceres.spoofax.GenerateWorkspaceConfig
func createWorkspaceConfig(workspaceRoot: path) -> WorkspaceConfig? = {
  val workspaceFile = workspaceRoot.resolve(./root/workspace.cfg);
  if(!exists workspaceFile) return null;
  val text = read workspaceFile;
  val workspaceConfig = generateWorkspaceConfig(text, workspaceRoot);
  return workspaceConfig;
}

/// Eclipse project processing
func processProject(root: path, project: path) -> (path, Token*?, Message*, Styling?)* = {
  val workspaceConfig = createWorkspaceConfig(root);
  if(workspaceConfig == null) return [];
  val workspace = workspaceConfig!;
  val results = [processFileWithLangSpecConfig(file, project, workspace) | file <- walk project with extensions (workspace.extensions())];
  return results;
}

/// Eclipse editor processing
func processEditor(text: string, associatedFile: path, associatedProject: path, root: path) -> (Token*?, Message*, Styling?)? = {
  val workspaceConfig = createWorkspaceConfig(root);
  if(workspaceConfig == null) return null;
  val workspace = workspaceConfig!;
  
  val extension = associatedFile.extension();
  if(extension == null) return null;
  
  val langSpecConfig = workspace.langSpecConfigForExt(extension!);
  if(langSpecConfig != null) {
    return processStringWithLangSpecConfig(text, associatedProject, langSpecConfig!, workspace)?; 
  }
  
  return null;
}
func emptyResult(file: path) -> (path, Token*?, Message*, Styling?) = {
  val emptyTokens: Token*? = null;
  val emptyMessages: Message* = [];
  val emptyStyling: Styling? = null;
  return (file, emptyTokens, emptyMessages, emptyStyling);
}

/// File processing
func processFileWithLangSpecConfig(file: path, project: path, workspace: WorkspaceConfig) -> (path, Token*?, Message*, Styling?) = {
  val langSpec = langSpecConfigForPath(workspace, file);
  if(langSpec != null) {
    val text = read file; // Creates a dependency to file changes
    val (tokens, messages, styling) = processStringWithLangSpecConfig(text, project, langSpec!, workspace);
    return (file, tokens, messages, styling);
  } else {
    return emptyResult(file);
  }
}

/// String processing
func processStringWithLangSpecConfig(text: string, associatedProject: path, langSpec: LangSpecConfig, workspace: WorkspaceConfig) -> (Token*?, Message*, Styling?) = {
  val (ast, tokenStream, messages) = parse(text, associatedProject, langSpec, workspace);
  val styling : Styling? = if(tokenStream == null) null else style(tokenStream!, langSpec, workspace);
  return (tokenStream, messages, styling);
}

/// Parsing
func parse(text: string, associatedProject: path, langSpec: LangSpecConfig, workspace: WorkspaceConfig) -> (Ast?, Token*?, Message*) = {
  val mainFile = langSpec.getSyntaxMainFile();
  val startSymbol = langSpec.getSyntaxStartSymbol();
  if(mainFile == null || startSymbol == null) return emptyParse();

  val parseTable = sdf2table(associatedProject, mainFile!, []);
  if(parseTable == null) return emptyParse();
  return jsglrParse(text, startSymbol!, parseTable!);
}
func emptyParse() -> (Ast?, Token*?, Message*) = {
  val emptyAst: Ast? = null;
  val emptyTokens: Token*? = null;
  val emptyMessages: Message* = [];
  return (emptyAst, emptyTokens, emptyMessages);
}

/// Syntax styling
func style(tokenStream: Token*, langSpec: LangSpecConfig, workspace: WorkspaceConfig) -> Styling? = {
  val mainFile = langSpec.getSyntaxBasedStylingFile();
  if(mainFile == null) return null;

  val syntaxStyler = esv2styler(mainFile!, []);
  if(syntaxStyler == null) return null;
  return esvStyle(tokenStream, syntaxStyler!)?;
}
