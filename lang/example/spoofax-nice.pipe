// Language specification configuration: configuring how to parse and style programs of the language.
data LangSpecConfig = foreign java mb.pipe.run.spoofax.cfg.LangSpecConfig {
  func getSyntaxMainFile() -> path
  func getSyntaxStartSymbol() -> string
  func getSyntaxStylingMainFile() -> path
}


// Parsing: going from a string, to an AST, token stream, and error messages.
data Message = foreign java mb.pipe.run.core.model.message.Msg {}
data Ast = foreign java org.spoofax.interpreter.terms.IStrategoTerm {}
data Token = foreign java mb.pipe.run.core.model.parse.Token {}
data ParseTable = foreign java mb.pipe.run.spoofax.sdf.Table {}
func sdf2table(mainFile: path, project: path) -> (ParseTable, path*) = foreign mb.pipe.run.ceres.spoofax.GenerateTable
func jsglrParse(text: string, startSymbol: string, pt: ParseTable) -> (Ast?, Token*?, Message*) = foreign mb.pipe.run.ceres.spoofax.Parse

func parse(text: string, project: path, langSpec: LangSpecConfig) -> (Ast?, Token*?, Message*) = {
  val mainFile = langSpec.getSyntaxMainFile();
  requires mainFile;
  val startSymbol = langSpec.getSyntaxStartSymbol();
  val (parseTable, deps) = sdf2table(mainFile, project);
  requires dep; | dep <- deps;
  return jsglrParse(text, startSymbol, parseTable);
}


// Syntax styling: going from token stream to a styling of that stream.
data Styling = foreign java mb.pipe.run.core.model.style.Styling {}
data SyntaxStyler = foreign java mb.pipe.run.spoofax.esv.StylingRules {}
func esv2styler(mainFile: path) -> (SyntaxStyler, path*) = foreign mb.pipe.run.ceres.spoofax.GenerateStylerRules
func esvStyle(tokenStream: Token*, st: SyntaxStyler) -> Styling = foreign mb.pipe.run.ceres.spoofax.Style

func style(tokenStream: Token*, langSpec: LangSpecConfig) -> Styling = {
  val mainFile = langSpec.getSyntaxStylingMainFile();
  requires mainFile;
  val (syntaxStyler, deps) = esv2styler(mainFile);
  requires dep; | dep <- deps;
  return esvStyle(tokenStream, syntaxStyler);
}


// Processing of text and files: combining parsing and syntax highlighting.
func processString(text: string, project: path, langSpec: LangSpecConfig) -> (Message*, Styling?) = {
  val (ast, tokenStream, messages) = parse(text, project, langSpec);
  val styling : Styling? = if(tokenStream == null) null else (style(tokenStream!, langSpec)?);
  return (messages, styling);
}
func processFile(file: path, project: path, langSpec: LangSpecConfig) -> (Message*, Styling?) = {
  val text = read file; // Creates a dependency to file changes
  val (messages, styling) = processString(text, project, langSpec);
  return (messages, styling);
}


// Workspace configuration: configuring which languages we are developing for use in the Eclipse workspace.
data WorkspaceConfig = foreign java mb.pipe.run.spoofax.cfg.WorkspaceConfig {
  func extensions() -> string*
  func langSpecConfigForExt(extension: string) -> LangSpecConfig?
}
func createWorkspace(text: string, root: path) -> WorkspaceConfig? = foreign mb.pipe.run.ceres.spoofax.GenerateWorkspaceConfig
func getLangSpec(workspace: WorkspaceConfig, path: path) -> LangSpecConfig? = {
  val extension: string? = path.extension();
  if(extension == null) return null;
  return workspace.langSpecConfigForExt(extension!);
}
func getWorkspace(root: path) -> WorkspaceConfig? = {
  val workspaceFile = root.resolve(./root/workspace.cfg);
  if(!exists workspaceFile) return null;
  val text = read workspaceFile;
  val workspaceConfig = createWorkspace(text, root);
  return workspaceConfig;
}


/// Eclipse project processing: process all programs of a language specification, in an Eclipse project.
func updateProject(root: path, project: path) -> (path, Message*, Styling?)* = {
  val workspaceConfig = getWorkspace(root);
  if(workspaceConfig == null) return [];
  val workspace = workspaceConfig!;
  val results = [updateFile(file, project, workspace) | file <- walk project with extensions (workspace.extensions())];
  return results;
}
func updateFile(file: path, project: path, workspace: WorkspaceConfig) -> (path, Message*, Styling?) = {
  val langSpec = getLangSpec(workspace, file);
  if(langSpec == null) return (file, [], null);
  val (messages, styling) = processFile(file, project, langSpec!);
  return (file, messages, styling);
}


/// Eclipse editor processing: process an editor containing a program of a language specification.
func updateEditor(text: string, file: path, project: path, root: path) -> (Message*, Styling?)? = {
  val workspace = getWorkspace(root);
  if(workspace == null) return null;
  
  val extension = file.extension();
  if(extension == null) return null;
  
  val langSpec = workspace!.langSpecConfigForExt(extension!);
  if(langSpec == null) return null;
  
  return processString(text, project, langSpec!)?;
}
