/// Generic library
// Resource
data Resource = java mb.pipe.run.vfs.IResource {
  func uri() -> string
  
  func resolve(string) -> Resource
  func resolveWithExt(uri : string, ext : string) -> Resource
}
func readFile(Resource) -> string = pluto mb.pipe.run.pluto.vfs.Read
func resolve(string) -> Resource = java mb.pipe.run.core.vfs.VFSResource#resolveStatic
func resolveAll(string*) -> Resource* = java mb.pipe.run.core.vfs.VFSResource#resolveAllStatic


/// Interface that Spoofax expects from a language
data Message = java mb.pipe.run.core.model.IMsg {}
data Ast = java org.spoofax.interpreter.terms.IStrategoTerm {}
data Token = java org.spoofax.jsglr.client.imploder.IToken {}
// func parse(text : string) -> (Ast?, Token*?, Message*)

data Styling = java mb.pipe.run.core.model.Styling {}
// func style(ast : Ast, tokenStream : Token*) -> Styling


/// Library with functions to build SDF and ESV specifications
data ParseTable = java mb.pipe.run.spoofax.sdf.Table {}
func sdf2table(langLoc : Resource, specDir : Resource, mainFile : Resource, includedFiles : Resource*) -> ParseTable? = pluto mb.pipe.run.pluto.sdf.GenerateTable
func jsglrParse(text : string, startSymbol : string, pt : ParseTable) -> (Ast?, Token*?, Message*) = pluto mb.pipe.run.pluto.sdf.Parse

data SyntaxStyler = java mb.pipe.run.impl.esv.SyntaxStyler {}
func esv2styler(files : Resource*) -> SyntaxStyler? = pluto mb.pipe.run.impl.esv.GenerateStyler
func esvStyle(ast : Ast, tokenStream : Token*, st : SyntaxStyler) -> Styling = pluto mb.pipe.run.impl.esv.Style


/// Implement parse and style
func parse(text : string) -> (Ast?, Token*?, Message*) = {
  var langLoc = resolve("/Users/gohla/.m2/repository/org/metaborg/org.metaborg.meta.lang.template/2.2.0/org.metaborg.meta.lang.template-2.2.0.spoofax-language");
  var specDir = resolve(".");  
  var mainFile = resolve("syntax/Lang.sdf3");
  var includedFiles = resolveAll(["syntax/Common.sdf3", "syntax/stuff.sdf3"]);
  var parseTable = sdf2table(langLoc, specDir, mainFile, includedFiles);
  if(parseTable == null) fail "Unable to build parse table";
  
  return jsglrParse(text, "Start", parseTable!);
}

func style(ast : Ast, tokenStream : Token*) -> Styling = {
  var esvFiles = resolveAll(["editor/Main.esv", "editor/Syntax.esv"]);
  var syntaxStyler = esv2styler(esvFiles);
  if(syntaxStyler == null) fail "Unable to build syntax styler";
  return esvStyle(ast, tokenStream, syntaxStyler!);
}


/// Implement pipelines
// File pipeline
func filePipeline(file : Resource) -> (Resource, Ast?, Token*?, Message*) = {
  var text = readFile(file); // Creates a dependency to file changes
  var (ast, tokenStream, messages) = parse(text);
  return (file, ast, tokenStream, messages);
}

// Eclipse editor pipeline
data EclipseEditor = java mb.pipe.run.eclipse.Editor {}
func readEditorBuffer(EclipseEditor) -> string = pluto mb.pipe.run.eclipse.ReadEditorBuffer 
func editorPipeline(editor : EclipseEditor) -> (EclipseEditor, Ast?, Token*?, Message*, Styling?) = {
  var text = readEditorBuffer(editor); // Creates a dependency to editor buffer changes
  var (ast, tokenStream, messages) = parse(text);
  var styling : Styling?;
  if(ast != null && tokenStream != null) {
    styling = style(ast!, tokenStream!);
  } else {
    styling = null;
  }
  return (editor, ast, tokenStream, messages, styling);
}