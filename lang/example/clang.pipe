func main(compileFlags: string*) -> string = {
  val files : path* = [./src/lib.c, ./test/check_lib.c];
  val includeDirs   = [./src/];
  val objectFiles   = [compile(file, includeDirs, compileFlags) | file <- files];
  
  val linkFlags = ["-lc", "-lcrt1.10.5.o", "-lcheck"];
  val testExe = link(objectFiles, ./bin/test, linkFlags);
  
  return test(testExe);
}

func compile(file: path, includeDirs: path*, flags: string*) -> path = {
  requires file;
  requires dir filter "*.h" | dir <- includeDirs;
  
  val objectFile = file.replaceExtension("o");
  exec(["clang"] + "$file" + ["-I$dir" | dir <- includeDirs] + "-o$objectFile" + "-c" + "-MMD" + flags);
  
  val depFile = file.replaceExtension("d");
  requires dep by hash | dep <- extractCompileDeps(depFile);
  
  return generates objectFile;
}

func extractCompileDeps(depFile: path) -> path* = foreign mb.pipe.run.ceres.clang.ExtractCompileDeps

func link(inputFiles: path*, outputFile: path, flags: string*) -> path = {
  requires file by hash | file <- inputFiles;
  exec(["ld"] + ["$file" | file <- inputFiles] + "-o" + "$outputFile" + flags);
  return generates outputFile;
}

func test(testExe: path) -> string = {
  requires testExe by hash;
  val (testReport, _) = exec(["$testExe"]);
  return testReport;
}

func exec(arguments: string*) -> (string, string) = foreign mb.pipe.run.ceres.process.Execute
