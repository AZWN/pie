/// Generic library
data Context = java mb.pipe.run.core.model.Context {
  func currentDir() -> Path
}

data Path = java mb.pipe.run.core.path.PPath {
  func extension() -> string?
  
  func parent() -> Path?
  func leaf() -> Path?
  func resolve(string) -> Path
}
func exists(Path) -> bool = ceres mb.pipe.run.ceres.path.Exists // Creates a dependency to file/directory existance
func listContents(Path, PathMatcher?) -> Path* = ceres mb.pipe.run.ceres.path.ListContents // Creates a dependency to directory contents changes
func walkContents(Path, PathWalker?) -> Path* = ceres mb.pipe.run.ceres.path.WalkContents // Creates a dependency to recursive directory contents changes
func readFile(Path) -> string = ceres mb.pipe.run.ceres.path.Read // Creates a dependency to file changes
func resolveAbs(string) -> Path = kotlin mb.pipe.run.ceres.path#resolve

data PathMatcher = java mb.pipe.run.core.path.PathMatcher {}
data PathWalker = java mb.pipe.run.core.path.PathWalker {}
func extensionsPathMatcher(string*) -> PathMatcher = java mb.pipe.run.core.path.PPaths#extensionsPathMatcher
func extensionsPathWalker(string*) -> PathWalker = java mb.pipe.run.core.path.PPaths#extensionsPathWalker



/// Interface that Spoofax expects from a language
data Message = java mb.pipe.run.core.model.message.Msg {}
data Ast = java org.spoofax.interpreter.terms.IStrategoTerm {}
data Token = java mb.pipe.run.core.model.parse.Token {}

data Styling = java mb.pipe.run.core.model.style.Styling {}



/// Library with functions to build SDF3 and ESV specifications
data ParseTable = java mb.pipe.run.spoofax.sdf.Table {}
func sdf2table(langLoc: Path, specDir: Path, mainFile: Path, includedFiles: Path*) -> ParseTable? = ceres mb.pipe.run.ceres.spoofax.GenerateTable
func jsglrParse(text: string, startSymbol: string, pt: ParseTable) -> (Ast?, Token*?, Message*) = ceres mb.pipe.run.ceres.spoofax.Parse

data SyntaxStyler = java mb.pipe.run.spoofax.esv.StylingRules {}
func esv2styler(langLoc: Path, specDir: Path, mainFile: Path, includedFiles: Path*) -> SyntaxStyler? = ceres mb.pipe.run.ceres.spoofax.GenerateStylerRules
func esvStyle(tokenStream: Token*, st: SyntaxStyler) -> Styling = ceres mb.pipe.run.ceres.spoofax.Style



/// Language specification configuration
data LangSpecConfig = java mb.pipe.run.spoofax.cfg.LangSpecConfig {
  func extensions() -> string*
  func getName() -> string?
  func getSyntaxMainFile() -> Path?
  func getSyntaxStartSymbol() -> string?
  func getSyntaxBasedStylingFile() -> Path?
}
func generateLangSpecConfig(langLoc: Path, file: Path) -> LangSpecConfig? = ceres mb.pipe.run.ceres.spoofax.GenerateLangSpecConfig
func getLangSpecConfig(file: Path, workbenchRoot: Path) -> LangSpecConfig? = {
  var workspaceConfig = createWorkspaceConfig(workbenchRoot);
  var extension = file.extension();
  if(extension == null) {
    fail "Cannot process a file without an extension";
  }
  var config = workspaceConfig.langSpecConfigForExt(extension!);
  return config;
}


/// Spoofax Core language configuration
data SpxCoreLangConfig = java mb.pipe.run.spoofax.cfg.SpxCoreLangConfig {
  func location() -> Path
  func extension() -> string
}
func generateSpxCoreLangConfig(langLoc: Path, extension: string) -> SpxCoreLangConfig = java mb.pipe.run.spoofax.cfg.SpxCoreLangConfig#generate
func getSpxCoreLangConfig(file: Path, workbenchRoot: Path) -> SpxCoreLangConfig? = {
  var workspaceConfig = createWorkspaceConfig(workbenchRoot);
  var extension = file.extension();
  if(extension == null) {
    fail "Cannot process a file without an extension";
  }
  var config = workspaceConfig.spxCoreLangConfigForExt(extension!);
  return config;
}


/// Spoofax Core language specification configuration
data SpxCoreLangSpecConfig = java mb.pipe.run.spoofax.cfg.SpxCoreLangSpecConfig {
  func location() -> Path
  func extension() -> string
}
func generateSpxCoreLangSpecConfig(langLoc: Path, extensions: string*) -> SpxCoreLangSpecConfig = java mb.pipe.run.spoofax.cfg.SpxCoreLangSpecConfig#generate
func createSpxCoreLangSpecConfig(langLoc: Path) -> SpxCoreLangSpecConfig = {
  var project = spxCoreLoadProject(langLoc);
  var langDir = project.directory();
  spxCoreBuildProject(langDir);
  spxCoreBuildLangSpec(langDir);
  var langImpl = spxCoreLoadLang(langDir);
  var extensions = spxCoreExtensions(langImpl.id());
  return generateSpxCoreLangSpecConfig(langDir, extensions);
}
func getSpxCoreLangSpecConfig(file: Path, workbenchRoot: Path) -> SpxCoreLangSpecConfig? = {
  var workspaceConfig = createWorkspaceConfig(workbenchRoot);
  var extension = file.extension();
  if(extension == null) {
    fail "Cannot process a file without an extension";
  }
  var config = workspaceConfig.spxCoreLangSpecConfigForExt(extension!);
  return config;
}


/// Combined configuration for the entire workspace
data WorkspaceConfig = java mb.pipe.run.spoofax.cfg.WorkspaceConfig {
  func allExtensions() -> string*
  func langSpecExtensions() -> string*
  func spxCoreLangExtensions() -> string*
  func spxCoreLangSpecExtensions() -> string*
  
  func langSpecConfigForExt(extension: string) -> LangSpecConfig?
  func spxCoreLangConfigForExt(extension: string) -> SpxCoreLangConfig?
  func spxCoreLangSpecConfigForExt(extension: string) -> SpxCoreLangSpecConfig?
}
func generateWorkspaceConfig(langSpecConfigs: LangSpecConfig*, spxCoreLangConfigs: SpxCoreLangConfig*, spxCoreLangSpecConfigs: SpxCoreLangSpecConfig*) -> WorkspaceConfig = java mb.pipe.run.spoofax.cfg.WorkspaceConfig#generate
func createWorkspaceConfig(workbenchRoot: Path) -> WorkspaceConfig = {
  var cfgLangLoc = resolveAbs("/Users/gohla/metaborg/repo/pipeline/cfg/langspec");
  var configs: LangSpecConfig* = [];

  // Language specification configurations
  // Check for a config in the workbench root
  var rootConfigFile = workbenchRoot.resolve("langspec.cfg");
  if(exists(rootConfigFile)) { // Creates a dependency to config file existance
    var config = generateLangSpecConfig(cfgLangLoc, rootConfigFile); // Creates a dependency to file changes
    if(config != null) {
      configs = [configs|config!];
    }
  }
  // Check for a config in all subdirectories
  // TODO: create a path matcher for langspec.cfg files
  foreach(var path in listContents(workbenchRoot, null)) { // Creates a dependency to directory changes
    var configFile = path.resolve("langspec.cfg");
    if(exists(configFile)) { // Creates a dependency to config file existance
      var config = generateLangSpecConfig(cfgLangLoc, configFile); // Creates a dependency to file changes
      if(config != null) {
        configs = [configs|config!];
      }
    }
  }
  
  // Spoofax core language configurations
  var spxCoreLangConfigs: SpxCoreLangConfig* = [
    generateSpxCoreLangConfig(resolveAbs("/Users/gohla/spoofax/master/repo/spoofax-releng/sdf/org.metaborg.meta.lang.template"), "sdf3")
  , generateSpxCoreLangConfig(resolveAbs("/Users/gohla/spoofax/master/repo/spoofax-releng/esv/org.metaborg.meta.lang.esv"), "esv")
  , generateSpxCoreLangConfig(cfgLangLoc, "cfg")
  ];
  
  // Spoofax core language specification configurations
  var spxCoreLangSpecConfigs: SpxCoreLangSpecConfig* = [];
  // TODO: create a path matcher for pom.xml and metaborg.yaml files
  foreach(var path in listContents(workbenchRoot, null)) { // Creates a dependency to directory changes
    var pomFile = path.resolve("pom.xml");
    var metaborgYamlFile = path.resolve("metaborg.yaml");
    if(exists(pomFile) && exists(metaborgYamlFile)) { // Creates a dependency to config file existance
      var config = createSpxCoreLangSpecConfig(path); // Creates a dependency to file changes
      spxCoreLangSpecConfigs = [spxCoreLangSpecConfigs|config];
    }
  }
  
  return generateWorkspaceConfig(configs, spxCoreLangConfigs, spxCoreLangSpecConfigs);
}



/// General processing
func processProject(context: Context, workbenchRoot: Path) -> (Path, Token*?, Message*, Styling?)* = {
  var workspaceConfig = createWorkspaceConfig(workbenchRoot);
  var results: (Path, Token*?, Message*, Styling?)* = [];
  
  // Go over each file with a corresponding language specification config
  foreach(var file in walkContents(context.currentDir(), extensionsPathWalker(workspaceConfig.langSpecExtensions())?)) {
    var config = getLangSpecConfig(file, workbenchRoot);
    if(config != null) {
      var (tokens, messages, styling) = processFileWithLangSpecConfig(file, context, config!);
      results = [results|(file, tokens, messages, styling)];
    } else {
      // If no config was found for the file, do not process it and return an empty results.
      // This also registers the correct dependencies.
      var emptyTokens: Token*? = null;
      var emptyMessages: Message* = [];
      var emptyStyling: Styling? = null;
      results = [results|emptyResult(file)];
    }
  }
  
  // Go over each file with a corresponding Spoofax Core language config
  foreach(var file in walkContents(context.currentDir(), extensionsPathWalker(workspaceConfig.spxCoreLangExtensions())?)) {
    var config = getSpxCoreLangConfig(file, workbenchRoot);
    if(config != null) {
      var (tokens, messages, styling) = processFileWithSpxCoreLang(file, context, config!);
      results = [results|(file, tokens, messages, styling)];
    } else {
      // If no config was found for the file, do not process it and return an empty results.
      // This also registers the correct dependencies.
      results = [results|emptyResult(file)];
    }
  }
  
  return results;
}
func emptyResult(file: Path) -> (Path, Token*?, Message*, Styling?) = {
  var emptyTokens: Token*? = null;
  var emptyMessages: Message* = [];
  var emptyStyling: Styling? = null;
  return (file, emptyTokens, emptyMessages, emptyStyling);
}
func processString(text: string, associatedFile: Path, context: Context, workbenchRoot: Path) -> (Token*?, Message*, Styling?)? = {
  var langSpecConfig = getLangSpecConfig(associatedFile, workbenchRoot);
  if(langSpecConfig != null) {
    return processStringWithLangSpecConfig(text, context, langSpecConfig!)?; 
  }
  var spxCoreLangConfig = getSpxCoreLangConfig(associatedFile, workbenchRoot);
  if(spxCoreLangConfig != null) {
    return processStringWithSpxCoreLang(text, associatedFile, context, spxCoreLangConfig!)?; 
  }
  // No config found for file, do not process file, but this does register a dependency.
  return null;
}



/// Processing of programs of language specifications
func processFileWithLangSpecConfig(file: Path, context: Context, langSpecConfig: LangSpecConfig) -> (Token*?, Message*, Styling?) = {
  var text = readFile(file); // Creates a dependency to file changes
  return processStringWithLangSpecConfig(text, context, langSpecConfig);
}
func processStringWithLangSpecConfig(text: string, context: Context, langSpecConfig: LangSpecConfig) -> (Token*?, Message*, Styling?) = {
  var (ast, tokenStream, messages) = parse(text, context, langSpecConfig);
  var styling: Styling?;
  if(tokenStream != null) {
    styling = style(tokenStream!, context, langSpecConfig);
  } else {
    styling = null;
  }
  return (tokenStream, messages, styling);
}
func parse(text: string, context: Context, langSpecConfig: LangSpecConfig) -> (Ast?, Token*?, Message*) = {
  var mainFile = langSpecConfig.getSyntaxMainFile();
  var startSymbol = langSpecConfig.getSyntaxStartSymbol();
  if(mainFile == null || startSymbol == null) {
    var emptyAst: Ast? = null;
    var emptyTokens: Token*? = null;
    var emptyMessages: Message* = [];
    return (emptyAst, emptyTokens, emptyMessages);
  }
  
  var langLoc = resolveAbs("/Users/gohla/spoofax/master/repo/spoofax-releng/sdf/org.metaborg.meta.lang.template");
  var specDir = context.currentDir();
  var includedFiles: Path* = [];
  includedFiles = [];

  var parseTable = sdf2table(langLoc, specDir, mainFile!, includedFiles);
  if(parseTable == null) fail "Unable to build parse table";
  
  return jsglrParse(text, startSymbol!, parseTable!);
}
func style(tokenStream: Token*, context: Context, langSpecConfig: LangSpecConfig) -> Styling? = {
  var mainFile = langSpecConfig.getSyntaxBasedStylingFile();
  if(mainFile == null) {
    return null;
  }
  
  var langLoc = resolveAbs("/Users/gohla/spoofax/master/repo/spoofax-releng/esv/org.metaborg.meta.lang.esv");
  var specDir = context.currentDir();
  var includedFiles: Path* = [];
  
  var syntaxStyler = esv2styler(langLoc, specDir, mainFile!, includedFiles);
  if(syntaxStyler == null) fail "Unable to build syntax styler";
  
  return esvStyle(tokenStream, syntaxStyler!)?;
}



/// Spoofax Core interoperability
/// Native functions
// Language loading
transient data LangImpl = java org.metaborg.core.language.ILanguageImpl {
  func id() -> LangId
}
data LangId = java org.metaborg.core.language.LanguageIdentifier {}
func spxCoreLoadLang(location: Path) -> LangImpl = ceres mb.pipe.run.ceres.spoofax.core.CoreLoadLang

// Project loading
transient data Project = java mb.pipe.run.ceres.spoofax.core.CoreLoadProj.Project {
  func directory() -> Path
}
func spxCoreLoadProject(directory: Path) -> Project = ceres mb.pipe.run.ceres.spoofax.core.CoreLoadProj

// Parsing
func spxCoreParse(langId: LangId, associatedFile: Path, text: string) -> (Ast?, Token*?, Message*) = ceres mb.pipe.run.ceres.spoofax.core.CoreParse 

// Analysis
func spxCoreAnalyze(langId: LangId, projectDir: Path, associatedFile: Path, ast: Ast) -> (Ast?, Message*) = ceres mb.pipe.run.ceres.spoofax.core.CoreAnalyze

// Transformation
data TransformGoal = java org.metaborg.core.action.ITransformGoal {}
func createCompileGoal() -> TransformGoal = kotlin mb.pipe.run.ceres.spoofax.core#createCompileGoal
func createNamedGoal(name: string) -> TransformGoal = kotlin mb.pipe.run.ceres.spoofax.core#createCompileGoal
func spxCoreTransform(langId: LangId, projectDir: Path, associatedFile: Path, ast: Ast, goal: TransformGoal) -> (Ast?, Path?) = ceres mb.pipe.run.ceres.spoofax.core.CoreTrans

// Building
func spxCoreBuildProject(projectDir: Path) -> void = ceres mb.pipe.run.ceres.spoofax.core.CoreBuild
func spxCoreBuildLangSpec(langSpecDir: Path) -> void = ceres mb.pipe.run.ceres.spoofax.core.CoreBuildLangSpec

// Extensions
func spxCoreExtensions(langId: LangId) -> string* = ceres mb.pipe.run.ceres.spoofax.core.CoreExtensions

// Styling
func spxCoreStyle(langId: LangId, tokens: Token*, ast: Ast) -> Styling = ceres mb.pipe.run.ceres.spoofax.core.CoreStyle


/// Interoperability functions
func processFileWithSpxCoreLang(file: Path, context: Context, config: SpxCoreLangConfig) -> (Token*?, Message*, Styling?) = {
  var text = readFile(file); // Creates a dependency to file changes
  return processStringWithSpxCoreLang(text, file, context, config);
}
func processStringWithSpxCoreLang(text: string, associatedFile: Path, context: Context, config: SpxCoreLangConfig) -> (Token*?, Message*, Styling?) = {
  var langImpl = spxCoreLoadLang(config.location());
  var langId = langImpl.id();
  var project = spxCoreLoadProject(context.currentDir());
  var projectDir = project.directory();
  var (ast, tokens, messages) = spxCoreParse(langId, associatedFile, text);
  var styling: Styling?;
  if(ast != null && tokens != null) {
    styling = spxCoreStyle(langId, tokens!, ast!)?;
  } else {
    styling = null;
  }
  return (tokens, messages, styling);
}
