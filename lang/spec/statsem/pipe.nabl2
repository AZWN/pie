module statsem/pipe

rules // Pipeline function implementation

  [[ FuncImpl(stm) ^ (s, ty_func_outer, occ_func_outer) ]] :=
    occ_func_outer.kind := PipelineFuncKind() !,
    [[ stm ^ (s, ty_func_outer) ]].

rules // Statements

  [[ Block(stms) ^ (s, ty_func_outer) ]] :=
    Map2 [[ stms ^ (s, ty_func_outer) ]].


  [[ ValDec(binder, exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty ]],
    Binder [[ binder ^ (s, ty) ]].
    

  [[ ListComprehensionStm(stm_map, binder, exp_list) ^ (s, ty_func_outer) ]] :=
    [[ exp_list ^ (s) : ty_list ]],
    ty_list == ListTy(ty_list_inner) | error $[Type mismatch: expected list type, got [ty_list]] @ exp_list,
    new s_comprehension,
    s_comprehension -P-> s,
    Binder [[ binder ^ (s_comprehension, ty_list_inner) ]],
    [[ stm_map ^ (s_comprehension, ty_func_outer) ]].


  [[ RequiresPath(exp, filter, stamper) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp,
    [[ filter ^ (s) ]],
    [[ stamper ^ (s) ]].

  [[ GeneratesPath(exp, stamper) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp,
    [[ stamper ^ (s) ]].

  [[ Modified() ^ (s) ]] := true.
  [[ Hash()     ^ (s) ]] := true.


  [[ Return(exp) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty_ret ]],
    ty_func_outer == FuncTy(_, ty_ret_expected),
    ty_ret <? ty_ret_expected | error $[Type mismatch: expected [ty_ret_expected], got [ty_ret]] @ exp.

  [[ Fail(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? StrTy() | error $[Type mismatch: expected string type, got [ty]] @ exp.


  [[ Exp(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : _ ]].

rules // If else statement

  [[ IfStm(exp_cond, stm) ^ (s, ty_func_outer) ]] :=
    [[ exp_cond ^ (s) : ty_cond ]],
    ty_cond <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_cond]] @ exp_cond,
    [[ stm ^ (s, ty_func_outer) ]].

  [[ e@IfElseStm(exp_cond, stm_true, stm_false) ^ (s, ty_func_outer) ]] :=
    [[ exp_cond ^ (s) : ty_cond ]],
    ty_cond <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_cond]] @ exp_cond,
    [[ stm_true ^ (s, ty_func_outer) ]],
    [[ stm_false ^ (s, ty_func_outer) ]].

rules // Unary expressions

  [[ ToNullable(exp) ^ (s) : NullableTy(ty) ]] :=
    [[ exp ^ (s) : ty ]],
    ty != NullableTy(_) | error $[Type mismatch: expected non-nullable type, got [ty]] @ exp.
    
  [[ ToNonNullable(exp) ^ (s) : ty_inner ]] :=
    [[ exp ^ (s) : ty ]],
    ty == NullableTy(ty_inner) | error $[Type mismatch: expected nullable type, got [ty]] @ exp.

  [[ Not(exp) ^ (s) : BoolTy() ]] :=
    [[ exp ^ (s) : ty ]],
    ty == BoolTy() | error $[Type mismatch: expected boolean type, got [ty]] @ exp.

rules // Binary expressions

  // TODO: should use LUB to work both ways. However, that requires separating nullability into a property 
  // of a type (by creating a tuple for each type), because otherwise LUB could always result into the top 
  // type TopTy(), instead of failing.
  [[ t@Eq(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? ty_l | error $[Type mismatch: cannot compare [ty_l] to [ty_r]] @ t.
  [[ t@Neq(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? ty_l | error $[Type mismatch: cannot compare [ty_l] to [ty_r]] @ t.

  [[ t@Lor(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    ty_l <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_l]] @ exp_l,
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_r]] @ exp_r.
  [[ t@Land(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    ty_l <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_l]] @ exp_l,
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_r]] @ exp_r.

  [[ t@Add(exp_l, exp_r) ^ (s) : ty ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty is addType of (ty_l, ty_r) | error $[Type mismatch: cannot add [ty_l] to [ty_r]] @ t.

rules // If else expression

  [[ If(exp_cond, exp) ^ (s) : ty ]] :=
    [[ exp_cond ^ (s) : ty_cond ]],
    ty_cond <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_cond]] @ exp_cond,
    [[ exp ^ (s) : ty ]].

  [[ e@IfElse(exp_cond, exp_true, exp_false) ^ (s) : ty_false ]] :=
    [[ exp_cond ^ (s) : ty_cond ]],
    ty_cond <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_cond]] @ exp_cond,
    [[ exp_true ^ (s)  : ty_true ]],
    [[ exp_false ^ (s) : ty_false ]],
    // TODO: this should calculate the LUB of the expression types
    ty_true <? ty_false | error $[Type mismatch: expected [ty_false], got [ty_true]] @ e.

rules // List comprehension expression

  [[ ListComprehensionExp(exp_map, binder, exp_list) ^ (s) : ty ]] :=
    [[ exp_list ^ (s) : ty_list ]],
    ty_list == ListTy(ty_list_inner) | error $[Type mismatch: expected list type, got [ty_list]] @ exp_list,
    new s_comprehension,
    s_comprehension -P-> s,
    Binder [[ binder ^ (s_comprehension, ty_list_inner) ]],
    [[ exp_map ^ (s_comprehension) : ty_map ]],
    ty == ListTy(ty_map).

rules // Variable reference
    
  [[ Ref(id_var) ^ (s) : ty ]] :=
    Var{id_var} -> s,
    Var{id_var} |-> v,
    v : ty.

rules // Function calls

  [[ Call(id_func, args) ^ (s) : ty_out ]] :=
    Func{id_func} -> s,
    Func{id_func} |-> f,
    f : ty_func,
    ty_func == FuncTy(tys_in_expected, ty_out) | error $[Type mismatch: expected function type, got [ty_func]] @ id_func,
    Map1T [[ args ^ (s) : tys_in ]],
    tys_in <? tys_in_expected | error $[Type mismatch: expected [tys_in_expected], got [tys_in]] @ id_func.

  [[ QCall(exp, id_func, args) ^ (s) : ty_out ]] :=
    // Get definition occurrences for primitive types
    Type{StrTy()} -> s , Type{StrTy() } |-> occ_def_str,
    Type{PathTy()} -> s, Type{PathTy()} |-> occ_def_path,
    [[ exp ^ (s) : ty_data ]],
    occ is typeToOcc of (ty_data, occ_def_str, occ_def_path) | error $[Type mismatch: expected callable type, got [ty_data]] @ exp, 
    occ ?=I=> s_assoc,
    new s_imp,
    s_imp -I-> s_assoc,
    Func{id_func} -> s_imp,
    Func{id_func} |-> f,
    f : FuncTy(tys_in_expected, ty_out),
    Map1T [[ args ^ (s) : tys_in ]], 
    tys_in <? tys_in_expected | error $[Type mismatch: expected [tys_in_expected], got [tys_in]] @ id_func.

rules // Path operations

  [[ ListPath(exp, filter) ^ (s) : ListTy(PathTy()) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp,
    [[ filter ^ (s) ]].    

  [[ WalkPath(exp, filter) ^ (s) : ListTy(PathTy()) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp,
    [[ filter ^ (s) ]].


  [[ Regex(exp) ^ (s) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? StrTy() | error $[Type mismatch: expected string type, got [ty_exp]] @ exp.
    
  [[ Pattern(exp) ^ (s) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? StrTy() | error $[Type mismatch: expected string type, got [ty_exp]] @ exp.
    
  [[ Patterns(exp) ^ (s) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? ListTy(StrTy()) | error $[Type mismatch: expected string* type, got [ty_exp]] @ exp.
    
  [[ Extension(exp) ^ (s) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? StrTy() | error $[Type mismatch: expected string type, got [ty_exp]] @ exp.
    
  [[ Extensions(exp) ^ (s) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? ListTy(StrTy()) | error $[Type mismatch: expected string* type, got [ty_exp]] @ exp.


  [[ ReadPath(exp) ^ (s) : StrTy() ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp.  

  [[ ExistsPath(exp) ^ (s) : BoolTy() ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp.  
    
rules // Simple literals

  [[ BoolLit(_) ^ (s) : BoolTy() ]] := true.
  [[ IntLit(_)  ^ (s) : IntTy()  ]] := true.
  [[ NullLit()  ^ (s) : NullTy() ]] := true.

rules // String literals with interpolation

  [[ StrLit(elems) ^ (s) : StrTy() ]] :=
    Map1 [[ elems ^ (s) ]].
    
  [[ Str(_) ^ (s) ]] := true.
  [[ StrInterpRef(exp_ref) ^ (s) ]] :=
    [[ exp_ref ^ (s) : _ ]].
  [[ StrInterpExp(exp) ^ (s) ]] :=
    [[ exp ^ (s) : _ ]].

rules // Path literals with interpolation

  [[ PathLit(_, elems) ^ (s) : PathTy() ]] :=
    Map1 [[ elems ^ (s) ]].
    
  [[ Path(_) ^ (s) ]] := true.
  [[ PathInterpRef(exp_ref) ^ (s) ]] :=
    [[ exp_ref ^ (s) : _ ]].
  [[ PathInterpExp(exp) ^ (s) ]] :=
    [[ exp ^ (s) : _ ]].

rules // Composite literals

  [[ TupleLit(exps) ^ (s) : TupleTy(tys) ]] :=
    Map1T [[ exps ^ (s) : tys ]].

  [[ ListLit([]) ^ (s) : ListTy(TopTy()) ]] := true.

  [[ ListLit([exp|exps]) ^ (s) : ListTy(ty) ]] :=
    // TODO: this should calculate the LUB of the expression types.
    [[ exp ^ (s) : ty ]],
    CompareTypes [[ exps ^ (s, ty) ]].
    
  CompareTypes [[ [exp|exps] ^ (s, ty_expected) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? ty_expected | error $[Type mismatch: expected [ty_expected], got [ty]] @ exp,
    CompareTypes [[ exps ^ (s, ty_expected) ]].

  CompareTypes [[ [] ^ (s, ty_expected) ]] := true.
