module gen/kotlin-ceres/stm

imports

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  statsem/program
  
  gen/kotlin-ceres/exp
  gen/kotlin-ceres/binder
  gen/kotlin/type2kotlin
  gen/idtype-tuples
  gen/util
  gen/debug

rules

  try-p2c-stm    = pipe-try-debug(p2c-stm|"p2c-stm") <+ !"{}"
  p2c-stms       = p2c-stms(|"\n")
  p2c-stms(|sep) = map(try-p2c-stm); separate-by(|sep); concat-strings

rules

  p2c-stm:
    Block(stms) -> 
$[{
  [str]
}]
    with
      str := <p2c-stms> stms

rules // Value declaration

  p2c-stm:
    ValDec(binder, exp) -> $[val [binderStr] = [expStr]]
    with
      binderStr := <p2c-binder> binder
    ; expStr    := <try-p2c-exp> exp

rules // If else statement

  p2c-stm:
    IfStm(condExp, stm) -> $[if([condExpStr]) [stmStr]]
    with
      condExpStr := <try-p2c-exp> condExp
    ; stmStr     := <try-p2c-stm> stm

  p2c-stm:
    IfElseStm(condExp, trueStm, falseStm) -> $[if([condExpStr]) [trueStmStr] else [falseStmStr]]
    with
      condExpStr  := <try-p2c-exp> condExp
    ; trueStmStr  := <try-p2c-stm> trueStm
    ; falseStmStr := <try-p2c-stm> falseStm

rules // List comprehension

  p2c-stm:
    ListComprehensionStm(mapStm, binder, listExp) -> $[[listExpStr].forEach {[binderStr] -> [mapStmStr]}]
    with
      mapStmStr  := <try-p2c-stm> mapStm
    ; binderStr  := <p2c-binder> binder
    ; listExpStr := <try-p2c-exp> listExp

rules // Path operations

  p2c-stm:
    RequiresPath(exp, filterOpt, stamper) -> $[require([expStr], [stamperStr])]
    with
      expStr     := <p2c-exp> exp
    ; stamperStr := <p2c-stamper> (filterOpt, stamper)

  p2c-stm:
    GeneratesPath(exp, stamper) -> $[generate([expStr], [stamperStr])]
    with
      expStr     := <p2c-exp> exp
    ; stamperStr := <p2c-stamper> (None(), stamper)
  
  p2c-stamper:
    (None(), Modified()) -> "PathStampers.modified"
  p2c-stamper:
    (None(), Hash()    ) -> "PathStampers.hash"
  p2c-stamper:
    (filter, Modified()) -> $[PathStampers.modified([filterStr])]
    where
      <not(?None())> filter
    with
      filterStr := <p2c-filter-match> filter
  p2c-stamper:
    (filter, Hash()) -> $[PathStampers.hash([filterStr])]
    where
      <not(?None())> filter
    with
      filterStr := <p2c-filter-match> filter

rules // Return and fail

  p2c-stm:
    Return(exp) -> $[return output([expStr])]
    where
      <pipe-ast-type; (?TupleTy(_) <+ NullableTy(?TupleTy(_)))> exp
    with
      expStr := <try-p2c-exp> exp

  p2c-stm:
    Return(exp) -> $[return [expStr]]
    where
      <pipe-ast-type; not(?TupleTy(_))> exp
    with
      expStr := <try-p2c-exp> exp


  p2c-stm:
    Fail(exp) -> $[throw BuildException([expStr].toString())]
    with
      expStr := <try-p2c-exp> exp

rules // Expression as statement

  p2c-stm:
    Exp(exp) -> $[[expStr]]
    with
      expStr := <try-p2c-exp> exp
