module impl/pipe

imports

  lex/literal
  type
  func

context-free syntax

  DataImpl =

context-free syntax

  FuncImpl.FuncImpl = <<Block>>

context-free syntax

  Block.Block = <{
  <{Stm "\n"}*>
}>
  Stm = <<Block>>

  Stm.IfStm     = <if(<Exp>) <Stm>>
  Stm.IfElseStm = <if(<Exp>) <Stm> else <Stm>>

  Binder.SingleBinder = <<Bind>>
  Binder.TupleBinder  = <(<{Bind ", "}*>)>

  Bind.Bind  = <<ID>>
  Bind.TBind = <<ID> : <Type>>

  Stm.ValDec = <val <Binder> = <Exp>;>
  
  Stm.ListComprehensionStm = <<Stm> | <Binder> \<- <Exp>;>
  
  Stm.RequiresPath        = <requires <Exp> <FilterPart?> <StamperPart?>;>
  Stm.GeneratesPath       = <generates <Exp> <StamperPart?>;>
  
  StamperPart.StamperPart = <by <StampKind>>
  StampKind.Modified      = <modified>
  StampKind.Hash          = <hash>
  
  Stm.Return = <return <Exp>;>
  Stm.Fail = <fail <Exp>;>
  
  Stm.Exp = <<Exp>;>

context-free syntax

  Exp.ToNullable    = <<Exp>?>
  Exp.ToNonNullable = <<Exp>!>
  Exp.Not           = <!<Exp>>

  Exp.Eq   = <<Exp> == <Exp>> {left}
  Exp.Neq  = <<Exp> != <Exp>> {left}
  Exp.Lor  = <<Exp> || <Exp>> {left}
  Exp.Land = <<Exp> && <Exp>> {left}
  Exp.Add  = <<Exp> + <Exp>>  {left}
  
  Exp.If     = <if(<Exp>) <Exp>>
  Exp.IfElse = <if(<Exp>) <Exp> else <Exp>>

  Exp.ListComprehensionExp = <[<Exp> | <Binder> \<- <Exp>]>

  Ref.Ref = <<ID>> {avoid}
  Exp     = Ref
  
  Exp.Call  = <<FUNCID>(<{Exp ", "}*>)>
  Exp.QCall = <<Exp>.<FUNCID>(<{Exp ", "}*>)>
  
  Exp.ListPath            = <list <Exp> <FilterPart?>> {left}
  Exp.WalkPath            = <walk <Exp> <FilterPart?>> {left}
  
  FilterPart.FilterPart   = <with <Filter>>
  Filter.Regex            = <regex <Exp>>
  Filter.Pattern          = <pattern <Exp>>
  Filter.Patterns         = <patterns <Exp>> {prefer} // Prefer over pattern to avoid additional s from being used for something else
  Filter.Extension        = <extension <Exp>>
  Filter.Extensions       = <extensions <Exp>> {prefer} // Prefer over extension to avoid additional s from being used for something else
  
  Exp.ReadPath            = <read <Exp>>
  Exp.ExistsPath          = <exists <Exp>>

  Exp.BoolLit = <<Bool>>
  Bool.True   = <true>
  Bool.False  = <false>

  Exp.IntLit  = <<INT>>

  Exp.NullLit = <null>

  Exp.TupleLit = <(<{Exp ","}+>)> 
  Exp.ListLit  = <[<{Exp ","}*>]>

  Exp = <(<Exp>)> {bracket, prefer} // Prefer bracket over tuple literal with 1 element

syntax // Interpolated string literal

  Exp-CF.StrLit = "\"" StrPart-CF* "\""
  
  StrPart-CF.Str          = StrChars-LEX
  StrPart-CF.StrInterpRef = "$" Ref-CF
  StrPart-CF.StrInterpExp =  "${" Exp-CF "}"
  
lexical syntax

  StrChars = StrChar+
  StrChar = ~[\"\$\n\r]
  StrChar = "\\\""
  StrChar = "\\$"

lexical restrictions

  StrChars -/- ~[\"\$\n\r]
  
syntax // Interpolated path literal

  Exp-CF.PathLit = PathStart-LEX PathPart-CF*
  
  PathPart-CF.Path          = PathChars-LEX
  PathPart-CF.PathInterpRef = "$" Ref-CF
  PathPart-CF.PathInterpExp =  "${" Exp-CF "}"
  
lexical syntax

  PathStart = "/"
  PathStart = "./"
  
  PathChars = PathChar+
  PathChar  = ~[\n\r\$\,\;\]\)\ ]
  PathChar  = "\\ "
  PathChar  = "\\$"

lexical restrictions

  PathChars -/- ~[\n\r\$\,\;\]\)\ ]

context-free priorities

  { left: 
    Exp.ListPath
    Exp.WalkPath
  } > { 
    left: 
    Exp.Eq
    Exp.Neq
  } > { 
    left:
    Exp.Lor
    Exp.Land
  } > { 
    left:
    Exp.Add 
  } 

lexical syntax

  FUNCID = "return" {reject}
  FUNCID = "requires" {reject}
  FUNCID = "generates" {reject}
  FUNCID = "list" {reject}
  FUNCID = "walk" {reject}
  FUNCID = "regex" {reject}
  FUNCID = "pattern" {reject}
  FUNCID = "patterns" {reject}
//  FUNCID = "extension" {reject}
//  FUNCID = "extensions" {reject}
