module gen/java/func_body

imports

  libspoofax/stratego/debug
  nabl2/api

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  statsem/pie
  
  gen/java/func_def
  gen/java/binder
  gen/java/type
  gen/idtype-tuples
  gen/util
  gen/debug

rules 

  try-p2j-exp = pie-try-debug(p2j-exp|"p2j-exp") <+ !"new Object()"
  
rules // Expression composition

  p2j-exp:
    Block(exps) -> 
$[{
  [str]
}]
    with
      str := <map(try-p2j-exp); pie-sep-concat(|";\n")> exps

rules // Unary expressions
  
  p2j-exp:
    ToNullable(exp) -> <p2j-exp> exp
    where
      NullableTy(ty) := <pie-ast-type> exp

  p2j-exp:
    ToNullable(exp) -> $[[expStr] as [tySig]?]
    with
      ty := <pie-ast-type> exp
    where
      not(NullableTy(_) := ty)
    with
      tySig  := <p2j-type-sig> ty
    ; expStr := <p2j-exp> exp

  p2j-exp:
    ToNonNullable(exp) -> $[[expStr]!!]
    with
      expStr := <p2j-exp> exp


  p2j-exp:
    Not(exp) -> $[![expStr]]
    with
      expStr := <p2j-exp> exp

rules // Binary expressions

  p2j-binexp(|symbol):
    (lExp, rExp) -> $[[lExpStr] [symbol] [rExpStr]]
    with
      lExpStr := <try-p2j-exp> lExp
    ; rExpStr := <try-p2j-exp> rExp
  
  p2j-exp: Eq(lExp, rExp) -> <p2j-binexp(|"==")> (lExp, rExp)
  p2j-exp: Neq(lExp, rExp) -> <p2j-binexp(|"!=")> (lExp, rExp)
  p2j-exp: Lor(lExp, rExp) -> <p2j-binexp(|"||")> (lExp, rExp)
  p2j-exp: Land(lExp, rExp) -> <p2j-binexp(|"&&")> (lExp, rExp)

rules // Control flow

  p2j-exp:
    If(condExp, exp) -> $[if([condExpStr]) [expStr]]
    with
      condExpStr := <try-p2j-exp> condExp
    ; expStr     := <try-p2j-exp> exp

  p2j-exp:
    IfElse(condExp, trueExp, falseExp) -> $[if([condExpStr]) [trueExpStr] else [falseExpStr]]
    with
      condExpStr  := <try-p2j-exp> condExp
    ; trueExpStr  := <try-p2j-exp> trueExp
    ; falseExpStr := <try-p2j-exp> falseExp

  p2j-exp:
    Add(lExp, rExp) -> result
    with
      lExpStr := <try-p2j-exp> lExp
    ; rExpStr := <try-p2j-exp> rExp
    ; lType   := <pie-ast-type> lExp
    ; rType   := <pie-ast-type> rExp
    ; result  := <p2j-add(|lType, rType, lExpStr, rExpStr)> ""

  p2j-add(|lType, rType, lExpStr, rExpStr):
    _ -> $[[lExpStr] + [rExpStr]]
    where
      (IntTy(), IntTy()) := (lType, rType)

  p2j-add(|lType, rType, lExpStr, rExpStr):
    _ -> $[[lExpStr] + [rExpStr]]
    where
      (StrTy(), _) := (lType, rType)

  p2j-add(|lType, rType, lExpStr, rExpStr):
    _ -> $[[lExpStr].resolve([rExpStr])]
    where
      (PathTy(), PathTy()) := (lType, rType)

  p2j-add(|lType, rType, lExpStr, rExpStr):
    _ -> $[[lExpStr].resolve([rExpStr])]
    where
      (PathTy(), StrTy()) := (lType, rType)

  p2j-add(|lType, rType, lExpStr, rExpStr):
    _ -> $[Stream.concat(([lExpStr]).stream(), Stream.of([rExpStr])).collect(Collectors.toList())]
    where
      (ListTy(a), a) := (lType, rType)

  p2j-add(|lType, rType, lExpStr, rExpStr):
    _ -> $[Stream.concat(([lExpStr]).stream(), ([rExpStr]).stream()).collect(Collectors.toList())]
    where
      (ListTy(a), ListTy(a)) := (lType, rType)


  p2j-exp:
    e@ListComprehension(mapExp, binder, listExp) -> $[[listExpStr].stream().map([tmpVar] -> {[assignmentsStr]["\n"][mapExpStr];}).collect(Collectors.toList())]
    with
      listExpStr            := <try-p2j-exp> listExp
    ; tmpVar                := <newname> "tmpVar"
    ; idList                := <p2j-binder> binder
    ; listExpTy             := <pie-ast-type> listExp
    ; ListTy(listExpElemTy) := listExpTy
    ; typeList              := <type-to-typeList(|binder)> listExpElemTy
    ; typeStrList           := <map(p2j-type-sig)> typeList
    ; bindList              := <zip> (idList, typeStrList)
    ; assignments           := <nmap-par(bind-tuple-to-string | 1, tmpVar)> bindList
    ; assignmentsStr        := <pie-concat-nl> assignments
    ; mapExpStr             := <try-p2j-exp> mapExp


  // nmap that passes an extra parameter to the strategy
  nmap-par(s : Int * c * a -> b | i, par) =
    ?[] + [s(|i,par) | nmap-par(s | <inc> i, par)]

rules // Binding

  p2j-exp:
    e@ValDec(binder, exp) -> $[final [expTyStr] [tmpVar] = [expStr];["\n"][assignmentsStr]]
    with
      expTy          := <pie-ast-type> exp
    ; expTyStr       := <p2j-type-sig> expTy
    ; tmpVar         := <newname> "tmpVar"
    ; expStr         := <try-p2j-exp> exp
    ; idList         := <p2j-binder> binder
    ; typeList       := <type-to-typeList(|binder)> expTy
    ; typeStrList    := <map(p2j-type-sig)> typeList
    ; bindList       := <zip> (idList, typeStrList)
    ; assignments    := <nmap-par(bind-tuple-to-string | 1, tmpVar)> bindList
    ; assignmentsStr := <pie-concat-nl> assignments
  
  type-to-typeList(|binder):
    TupleTy(typeList) -> typeList
    where
      <?TupleBinder(_)> binder
      
  type-to-typeList(|binder):
    ty -> [ ty ]
    where
      <not(?TupleTy(_))> ty <+ <?SingleBinder(_)> binder
  
  bind-tuple-to-string(|i, tmpVar):
    (varId, tyStr) -> $[final [tyStr] [varId] = [tmpVar].component[i]();]

rules // References

  p2j-exp:
    r@Ref(varId) -> <p2j-ref-add-transient-val(|varId)> r 
    where
      LocalVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
  
  p2j-exp: 
    Ref(varId) -> <fail>
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 0 := <InputKind>
      
  p2j-exp: 
    r@Ref(varId) -> <p2j-ref-add-transient-val(|"input")> r
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 1 := <InputKind>
      
  p2j-exp: 
    r@Ref(varId) -> <p2j-ref-add-transient-val(|$[input.[varId]])> r
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 2 := <InputKind>

  p2j-ref-add-transient-val(|str):
    ref -> $[[str].v]
    where
      <p2j-ref-is-transient> ref
    
  p2j-ref-add-transient-val(|str):
    ref -> str
    where
      <not(p2j-ref-is-transient)> ref
  
  p2j-ref-is-transient = 
      pie-ast-type
    ; (?DataTy(<id>) <+ ?NullableTy(DataTy(<id>)))
    ; pie-occ-prop(|"mods")
    ; collect-one(?Transient())

rules // Java foreign function calls

  p2j-exp:
    Call(funcId, exps) -> $[[javaClassId].[javaMethodId]([expStr])]
    where
      JavaForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId  := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; javaMethodId := <pie-ast-ref-prop(|"Func", "javaMethodId")> funcId
    ; expStr       := <map(try-p2j-exp); pie-concat-comma> exps

rules // Qualified function calls

  p2j-exp: 
    QCall(exp, funcId, argsExps) -> $[[expStr].[funcId]([argsExpStr])]
    with
      argsExpStr := <map(try-p2j-exp); pie-concat-comma> argsExps
    ; expStr     := <try-p2j-exp> exp

rules // PIE function calls
  
  p2j-exp:
    c@Call(funcId, _) -> <p2j-exp-pie-call(|javaClassId)> c
    where
      PieForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    
  p2j-exp: 
    c@Call(funcId, _) -> <p2j-exp-pie-call(|javaClassId)> c 
    where
      PieFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-sanitize-class-id> funcId


  p2j-exp-pie-call(|javaClassId):
   Call(funcId, exps) -> $[execContext.require(_[safeJavaClassId], [expStr])]
    with
      expStr              := <p2j-exp-pie-call-inputexp(|javaClassId)> exps
    ; safeJavaClassId     := <string-replace(|".", "_")> javaClassId
    ; rules(InjectValues :+= ($[_[safeJavaClassId]], $[[javaClassId]]))


  p2j-exp-pie-call-inputexp(|javaClassId):
    exps -> "null"
    where
      0 := <length> exps

  p2j-exp-pie-call-inputexp(|javaClassId):
    exps -> expStr
    where
      1 := <length> exps
    with
      [exp]  := exps
    ; expStr := <try-p2j-exp> exp
    
  p2j-exp-pie-call-inputexp(|javaClassId):
    exps -> $[[javaClassId].Input([expStr])]
    where
      length := <length> exps
    ; <gt> (length, 1)
    with
      expStr := <map(try-p2j-exp); pie-concat-comma> exps

rules // Path operations

  p2j-exp:
    RequiresPath(exp, filterOpt, stamper) -> $[execContext.require([expStr], [stamperStr])]
    with
      expStr     := <p2j-exp> exp
    ; stamperStr := <p2j-stamper> (filterOpt, stamper)

  p2j-exp:
    GeneratesPath(exp, stamper) -> $[execContext.provide([expStr], [stamperStr])]
    with
      expStr     := <p2j-exp> exp
    ; stamperStr := <p2j-stamper> (None(), stamper)
  
  p2j-stamper:
    (None(), Modified()) -> "FileSystemStampers.modified()"
  p2j-stamper:
    (None(), Hash()    ) -> "FileSystemStampers.hash()"
  p2j-stamper:
    (filter, Modified()) -> $[FileSystemStampers.modified([filterStr])]
    where
      <not(?None())> filter
    with
      filterStr := <p2j-filter-match> filter
  p2j-stamper:
    (filter, Hash()) -> $[FileSystemStampers.hash([filterStr])]
    where
      <not(?None())> filter
    with
      filterStr := <p2j-filter-match> filter

  p2j-exp:
    ListPath(exp, filterOpt) -> $[list([expStr], [matcherStr])]
    with
      expStr     := <p2j-exp> exp
    ; matcherStr := <p2j-filter-match> filterOpt
    
  p2j-exp:
    WalkPath(exp, filterOpt) -> $[execContext.walk([expStr], [walkerStr], [matcherStr])]
    with
      expStr                  := <p2j-exp> exp
    ; (walkerStr, matcherStr) := <p2j-filter-walk> filterOpt
      
  p2j-filter-match:
    None() -> $[null]
  p2j-filter-match:
    Regex(exp) -> $[PathNodeMatcher(RegexPathMatcher([expStr]))]
    with
      expStr := <try-p2j-exp> exp
  p2j-filter-match:
    Pattern(exp) -> $[PathNodeMatcher(PatternPathMatcher([expStr]))]
    with
      expStr := <try-p2j-exp> exp
  p2j-filter-match:
    Patterns(exp) -> $[PathNodeMatcher(PatternsPathMatcher([expStr]))]
    with
      expStr := <try-p2j-exp> exp
  p2j-filter-match:
    Extension(exp)  -> $[PathNodeMatcher(ExtensionPathMatcher([expStr]))]
    with
      expStr := <try-p2j-exp> exp
  p2j-filter-match:
    Extensions(exp)  -> $[PathNodeMatcher(ExtensionsPathMatcher([expStr]))]
    with
      expStr := <try-p2j-exp> exp

  p2j-filter-walk:
    None() -> ( $[null], $[null] )
  p2j-filter-walk:
    Regex(exp) -> ( $[PathNodeWalker(NoHiddenPathMatcher.instance)], $[PathNodeMatcher([matcher])] )
    with
      expStr  := <try-p2j-exp> exp
    ; matcher := $[RegexPathMatcher([expStr])]
  p2j-filter-walk:
    Pattern(exp) -> ( $[PathNodeWalker(NoHiddenPathMatcher.instance)], $[PathNodeMatcher([matcher])] )
    with
      expStr := <try-p2j-exp> exp
    ; matcher := $[PatternPathMatcher([expStr])]
  p2j-filter-walk:
    Patterns(exp) -> ( $[PathNodeWalker(NoHiddenPathMatcher.instance)], $[PathNodeMatcher([matcher])] )
    with
      expStr := <try-p2j-exp> exp
    ; matcher := $[PatternsPathMatcher([expStr])]
  p2j-filter-walk:
    Extension(exp) -> ( $[PathNodeWalker(NoHiddenPathMatcher.instance)], $[PathNodeMatcher([matcher])] )
    with
      expStr := <try-p2j-exp> exp
    ; matcher := $[ExtensionPathMatcher([expStr])]
  p2j-filter-walk:
    Extensions(exp) -> ( $[PathNodeWalker(NoHiddenPathMatcher.instance)], $[PathNodeMatcher([matcher])] )
    with
      expStr := <try-p2j-exp> exp
    ; matcher := $[ExtensionsPathMatcher([expStr])]

  p2j-exp:
    ReadPath(exp) -> $[readToString([expStr])]
    with
      expStr := <p2j-exp> exp
      
  p2j-exp:
    ExistsPath(exp) -> $[exists([expStr])]
    with
      expStr := <p2j-exp> exp

rules // Early return and failure

  p2j-exp:
    Return(exp) -> $[return [expStr]]
    with
      expStr := <p2j-pie-func-impl-returnvalue> exp

  p2j-exp:
    Fail(exp) -> $[throw ExecException([expStr].toString())]
    with
      expStr := <try-p2j-exp> exp

rules // Literals

  p2j-exp: UnitLit()        -> $[null]
  p2j-exp: BoolLit(True())  -> $[true]
  p2j-exp: BoolLit(False()) -> $[false]
  p2j-exp: IntLit(i)        -> i
  p2j-exp: NullLit()        -> $[null]


  p2j-exp:
    TupleLit(exps) -> $[tuple([expsStr])]
    with
      expsStr := <map(try-p2j-exp); pie-concat-comma> exps
    
  p2j-exp:
    ListLit(exps) -> $[new ArrayList<>(Arrays.asList([expsStr]))]
    with
      expsStr := <map(try-p2j-exp); pie-concat-comma> exps

rules // Interpolated string literal

  p2j-exp:
    StrLit(parts) -> $["[partsStr]"]
    with
      partsStr := <map(p2j-strpart); concat-strings> parts

  p2j-strpart:
    Str(chars) -> chars

  p2j-strpart:
    StrInterpRef(refExp) -> $[" + [refExpStr] + "]
    with
      refExpStr := <try-p2j-exp> refExp

  p2j-strpart:
    StrInterpExp(exp) -> $[${[expStr]}]
    with
      expStr := <try-p2j-exp> exp

rules // Interpolated path literal

  p2j-exp:
    PathLit(prefix, parts) -> $[new FSPath("[prefix][partsStr]")]
    with
      partsStr := <map(p2j-strpart); concat-strings> parts

  p2j-strpart:
    Path(chars) -> chars

  p2j-strpart:
    PathInterpRef(refExp) -> $[${[refExpStr]}]
    with
      refExpStr := <try-p2j-exp> refExp

  p2j-strpart:
    PathInterpExp(exp) -> $[${[expStr]}]
    with
      expStr := <try-p2j-exp> exp
