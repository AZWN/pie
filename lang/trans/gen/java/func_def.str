module gen/java/func_def

imports

  libspoofax/stratego/debug

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  gen/java/type
  gen/java/func_body
  gen/idtype-tuples
  gen/util

rules // PIE function definitions

  p2j-def:
    FuncDef(FuncHead(funcId, params, type), PieFuncImpl(body, optKeyBody)) -> str
    with
      className   := <pie-sanitize-class-id> funcId
    with
    {| InputKind, InjectValues:
      (inputName , inputDataClass)  := <p2j-pie-func-impl-inputsig(|className)> params
    ; (outputName, outputDataClass) := <p2j-pie-func-impl-outputsig(|className)> type
    ; execImpl          := <p2j-pie-func-impl-body(|<?UnitTy(); !False() <+ !True()> type)> body
    ; keyImpl           := <p2j-pie-func-key-body> optKeyBody
    ; injectTuples      := <bagof-InjectValues; make-set>
    ; fields            := <map(type-tuple-to-field); pie-concat-nl> injectTuples
    ; constructorParams := <map(type-tuple-to-param); pie-concat-commanl> injectTuples
    ; assignments       := <map(type-tuple-to-assignment); pie-concat-nl> injectTuples
    ; emptyReturn       := <?UnitTy(); !$[["\n"]return None.instance;] <+ !$[]> type
   |}
    with
      rules(ModuleBindings :+= $[bindTaskDef([className].class, "[className]");])
    with
      str := 
$[class [className] implements TaskDef<[inputName], [outputName]> {
  [fields]
  
  @Inject
  [className](
    [constructorParams]
  ) {
    [assignments]
  }
  private static final String _id = "[className]";
  
  [inputDataClass]
  
  [outputDataClass]
  
  public String getId() {
    return _id;
  }
  
  @Override
  public Serializable key([inputName] input) {
    [keyImpl]
  }
  
  @Override
  public [outputName] exec(ExecContext execContext, [inputName] input) throws Exception {
    try {
      [execImpl]
      [emptyReturn]
    } catch (Util.WrapperException e) {
      throw e.getWrappedException();
    }
  }
}
]

  p2j-pie-func-impl-body(|addReturn):
    Block(exps) -> 
$[
  [restExpsStr];
  [return][lastExpStr];
]
    with
      numExps     := <length> exps
    ; restExps    := <take(|<dec> numExps)> exps 
    ; restExpsStr := <map(try-p2j-exp); pie-sep-concat(|";\n")> restExps
    ; lastExp     := <last> exps
    ; lastExpStr  := <p2j-pie-func-impl-returnvalue> lastExp
    ; return      := <?True(); !$[return bladiebla] <+ !$[]> addReturn

  p2j-pie-func-impl-body(|addReturn):
    EmptyBlock() -> $[{ [return] }]
    with
      return := <?True(); !$[return null;] <+ !$[]> addReturn

  p2j-pie-func-impl-body(|addReturn):
    exp -> $[{ [return] [<p2j-pie-func-impl-returnvalue> <try-p2j-exp> exp];}]
    where
      <not(?Block(_) <+ ?EmptyBlock())> exp
    with
      return := <?True(); !$[return ] <+ !$[]> addReturn

  
  p2j-pie-func-impl-returnvalue:
    exp -> $[output([expStr])]
    where
      <pie-ast-type; (?TupleTy(_) <+ NullableTy(?TupleTy(_)))> exp
    with
      expStr := <try-p2j-exp> exp
      
  p2j-pie-func-impl-returnvalue:
    exp -> expStr
    where
      <pie-ast-type; not(?TupleTy(_))> exp
    with
      expStr := <try-p2j-exp> exp


  p2j-pie-func-impl-inputsig(|className):
    Params(params) -> ("None", "")
    where
      0 := <length> params
    with 
      rules(InputKind := 0)
      
  p2j-pie-func-impl-inputsig(|className):
    p@Params(params) -> (tySig, "")
    where
      1 := <length> params
    with
      [(_, ty)] := <pie-idtype-tuples> p
    ; tySig     := <p2j-type-sig> ty
    with 
      rules(InputKind := 1)
    
  p2j-pie-func-impl-inputsig(|className):
    p@Params(params) -> ($[[className].Input], $[[dataClassStr]["\n"]])
    where
      length := <length> params
    ; <gt> (length, 1)
    with
      idTypeTuples := <pie-idtype-tuples> p
    ; dataClassStr := <p2j-type-generate-dataclass(|"Input")> idTypeTuples
    with 
      rules(InputKind := 2)

    
  p2j-pie-func-impl-outputsig(|className):
    ty -> (<p2j-type-sig> ty, "")
    where
      <not(?TupleTy(_)); not(?NullableTy(TupleTy(_)))> ty
      
  p2j-pie-func-impl-outputsig(|className):
    ty -> ($[[className].Output], $[[dataClassStr]["\n"][outputFun]["\n\n"]])
    where
      <?TupleTy(_)> ty
    with
      idTypeTuples := <pie-idtype-tuples> ty
    ; dataClassStr := <p2j-type-generate-dataclass(|"Output")> idTypeTuples
    ; outputFun    := $[private fun output(tuple: [<p2j-type-sig> ty]) = Output(tuple)]

  p2j-pie-func-impl-outputsig(|className):
    ty -> ($[[className].Output?], $[[dataClassStr]["\n"][outputFun]["\n\n"]])
    where
      <?NullableTy(tty@TupleTy(_))> ty
    with
      idTypeTuples := <pie-idtype-tuples> tty
    ; dataClassStr := <p2j-type-generate-dataclass(|"Output")> idTypeTuples
    ; outputFun    := $[private fun output(tuple: [<p2j-type-sig> ty]) = if(tuple == null) null else Output(tuple)]

    
  p2j-pie-func-key-body:
    None() -> "return input;"
    
  p2j-pie-func-key-body:
    PieKeyFunc(exp) -> $[return [<try-p2j-exp> exp];]
