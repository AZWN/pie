module impl/pipe

imports

  lex/literal
  type
  func

context-free syntax

  DataImpl =

context-free syntax

  FuncImpl.FuncImpl = <<Block>>

context-free syntax

  Block.Block = <{
  <{Stm "\n"}*>
}>
  Stm = <<Block>>

  Binder.SingleBinder = <<Bind>> // TODO: implement gen
  Binder.TupleBinder  = <(<{Bind ", "}*>)> // TODO: implement gen

  Bind.Bind   = <<ID>> // TODO: implement gen
  Bind.TBind = <<ID> : <Type>> // TODO: implement gen

  Stm.VarDecBinder = <var <Binder> = <Exp>;>  // TODO: implement gen
  Stm.VarDec = <var <ID> : <Type>;>  // TODO: implement gen
  Stm.Assign = <<Ref> = <Exp>;>  // TODO: fix gen

  Stm.If = <if(<Exp>) <Stm>>
  Stm.IfElse = <if(<Exp>) <Stm> else <Stm>>
//  Stm.ForEach = <foreach(var <Binder> in <Exp>) <Stm>>
  
  Stm.Return = <return <Exp>;> // TODO: fix gen
  Stm.Fail = <fail <Exp>;> // TODO: implement gen
  
  Stm.Exp = <<Exp>;>

context-free syntax

  Exp.ToNullable = <<Exp>?>
  Exp.ToNonNullable = <<Exp>!>

  Exp.Eq = <<Exp> == <Exp>> {left} // TODO: fix gen
  Exp.Neq = <<Exp> != <Exp>> {left} // TODO: implement gen
  Exp.Lor = <<Exp> || <Exp>> {left} // TODO: implement gen
  Exp.Land = <<Exp> && <Exp>> {left} // TODO: implement gen

  Ref.Ref = <<ID>> {avoid}
  Exp = Ref
  
  Exp.Call = <<FUNCID>(<{Exp ", "}*>)> // TODO: fix gen
  Exp.QCall = <<Exp>.<FUNCID>(<{Exp ", "}*>)> // TODO: fix gen

  Exp.BoolLit = <<Bool>>
  Bool.True   = <true>
  Bool.False  = <false>

  Exp.IntLit  = <<INT>>
  Exp.StrLit  = <<STRING>>

  Exp.NullLit = <null>

  Exp.TupleLit = <(<{Exp ","}*>)> // TODO: implement gen
  Exp.ListLit  = <[<{Exp ","}*>]> // TODO: implement gen
//  Exp.ListAppendLit  = <[<Exp> | <{Exp ","}+>]> // TODO: implement gen

  Exp = <(<Exp>)> {bracket}

context-free priorities

  { left: Exp.Eq Exp.Neq } > { left: Exp.Lor Exp.Land }

lexical syntax

  FUNCID = "return" {reject}
  FUNCID = "foreach" {reject}
