module statsem/pipe

rules // Pipeline function implementation

  [[ FuncImpl(stm) ^ (s, ty_func_outer, occ_func_outer) ]] :=
    occ_func_outer.kind := PipelineFuncKind() !,
    [[ stm ^ (s, ty_func_outer) ]].

rules // Statements

  [[ Block(stms) ^ (s, ty_func_outer) ]] :=
    Map2 [[ stms ^ (s, ty_func_outer) ]].


  [[ ValDec(binder, exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty ]],
    Binder [[ binder ^ (s, ty) ]].
    

  [[ ListComprehensionStm(inner) ^ (s, _) ]] :=
    [[ inner ^ (s) : _ ]].


  [[ Return(exp) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty_ret ]],
    ty_func_outer == FuncTy(_, ty_ret_expected),
    ty_ret <? ty_ret_expected | error $[Type mismatch: expected [ty_ret_expected], got [ty_ret]] @ exp.

  [[ Fail(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? StrTy() | error $[Type mismatch: expected string type, got [ty]] @ exp.


  [[ Exp(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : _ ]].

rules // Unary expressions

  [[ ToNullable(exp) ^ (s) : NullableTy(ty) ]] :=
    [[ exp ^ (s) : ty ]],
    ty != NullableTy(_) | error $[Type mismatch: expected non-nullable type, got [ty]] @ exp.
    
  [[ ToNonNullable(exp) ^ (s) : ty_inner ]] :=
    [[ exp ^ (s) : ty ]],
    ty == NullableTy(ty_inner) | error $[Type mismatch: expected nullable type, got [ty]] @ exp.

  [[ Not(exp) ^ (s) : BoolTy() ]] :=
    [[ exp ^ (s) : ty ]],
    ty == BoolTy() | error $[Type mismatch: expected boolean type, got [ty]] @ exp.

rules // Binary expressions

  // TODO: should use LUB to work both ways. However, that requires separating nullability into a property 
  // of a type (by creating a tuple for each type), because otherwise LUB could always result into the top 
  // type TopTy(), instead of failing.
  [[ t@Eq(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? ty_l | error $[Type mismatch: cannot compare [ty_l] to [ty_r]] @ t.
  [[ t@Neq(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? ty_l | error $[Type mismatch: cannot compare [ty_l] to [ty_r]] @ t.

  [[ t@Lor(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    ty_l <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_l]] @ exp_l,
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_r]] @ exp_r.
  [[ t@Land(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    ty_l <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_l]] @ exp_l,
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_r]] @ exp_r.

rules // If else

  [[ If(exp_cond, exp) ^ (s) : ty ]] :=
    [[ exp_cond ^ (s) : ty_cond ]],
    ty_cond <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_cond]] @ exp_cond,
    [[ exp ^ (s) : ty ]].

  [[ e@IfElse(exp_cond, exp_true, exp_false) ^ (s) : ty_false ]] :=
    [[ exp_cond ^ (s) : ty_cond ]],
    ty_cond <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_cond]] @ exp_cond,
    [[ exp_true ^ (s)  : ty_true ]],
    [[ exp_false ^ (s) : ty_false ]],
    // TODO: this should calculate the LUB of the expression types
    ty_true <? ty_false | error $[Type mismatch: expected [ty_false], got [ty_true]] @ e.

rules // List comprehension

  [[ ListComprehensionExp(inner) ^ (s) : ty ]] :=
    [[ inner ^ (s) : ty ]].
    
  [[ ListComprehension(exp_map, binder, exp_list) ^ (s) : ty ]] :=
    [[ exp_list ^ (s) : ty_list ]],
    ty_list == ListTy(ty_list_inner) | error $[Type mismatch: expected list type, got [ty_list]] @ exp_list,
    new s_comprehension,
    s_comprehension -P-> s,
    Binder [[ binder ^ (s_comprehension, ty_list_inner) ]],
    [[ exp_map ^ (s_comprehension) : ty_map ]],
    ty == ListTy(ty_map).

rules // Variable reference
    
  [[ Ref(id_var) ^ (s) : ty ]] :=
    Var{id_var} -> s,
    Var{id_var} |-> v,
    v : ty.

rules // Function calls

  [[ Call(id_func, args) ^ (s) : ty_out ]] :=
    Func{id_func} -> s,
    Func{id_func} |-> f,
    f : ty_func,
    ty_func == FuncTy(tys_in_expected, ty_out) | error $[Type mismatch: expected function type, got [ty_func]] @ id_func,
    Map1T [[ args ^ (s) : tys_in ]],
    tys_in <? tys_in_expected | error $[Type mismatch: expected [tys_in_expected], got [tys_in]] @ id_func.

  [[ QCall(exp, id_func, args) ^ (s) : ty_out ]] :=
    [[ exp ^ (s) : ty_data ]],
    ty_data == DataTy(occ_data) | error $[Type mismatch: expected data type, got [ty_data]] @ exp, 
    occ_data ?=I=> s_assoc_data,
    new s_imp,
    s_imp -I-> s_assoc_data,
    Func{id_func} -> s_imp,
    Func{id_func} |-> f,
    f : FuncTy(tys_in_expected, ty_out),
    Map1T [[ args ^ (s) : tys_in ]], 
    tys_in <? tys_in_expected | error $[Type mismatch: expected [tys_in_expected], got [tys_in]] @ id_func.

rules // Requires/generates

  [[ Requires(exp, match, stamper) ^ (s) : PathTy() ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp,
    [[ match ^ (s) ]],
    [[ stamper ^ (s) ]].

  [[ Generates(exp, stamper) ^ (s) : PathTy() ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? PathTy() | error $[Type mismatch: expected path type, got [ty_exp]] @ exp,
    [[ stamper ^ (s) ]].
    
  [[ Filter(exp) ^ (s) ]] :=
    [[ exp ^ (s) : ty_exp ]],
    ty_exp <? StrTy() | error $[Type mismatch: expected string type, got [ty_exp]] @ exp.
  [[ Modified() ^ (s) ]] := true.
  [[ Hash() ^ (s) ]] := true.
    
rules // Simple literals

  [[ BoolLit(_) ^ (s) : BoolTy() ]] := true.
  [[ IntLit(_)  ^ (s) : IntTy()  ]] := true.
  [[ StrLit(_)  ^ (s) : StrTy()  ]] := true.
  [[ PathLit(_) ^ (s) : PathTy() ]] := true.
  [[ NullLit()  ^ (s) : NullTy() ]] := true.

rules // Composite literals

  [[ TupleLit(exps) ^ (s) : TupleTy(tys) ]] :=
    Map1T [[ exps ^ (s) : tys ]].

  [[ ListLit([]) ^ (s) : ListTy(TopTy()) ]] := true.

  [[ ListLit([exp|exps]) ^ (s) : ListTy(ty) ]] :=
    // TODO: this should calculate the LUB of the expression types.
    [[ exp ^ (s) : ty ]],
    CompareTypes [[ exps ^ (s, ty) ]].
    
  CompareTypes [[ [exp|exps] ^ (s, ty_expected) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? ty_expected | error $[Type mismatch: expected [ty_expected], got [ty]] @ exp,
    CompareTypes [[ exps ^ (s, ty_expected) ]].

  CompareTypes [[ [] ^ (s, ty_expected) ]] := true.
