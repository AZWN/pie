module statsem/pipe

rules // Pipeline function implementation

  [[ FuncImpl(stm) ^ (s, ty_func_outer, occ_func_outer) ]] :=
    occ_func_outer.kind := PipelineFuncKind() !,
    [[ stm ^ (s, ty_func_outer) ]].

rules // Statements

  [[ Block(stms) ^ (s, ty_func_outer) ]] :=
    Map2 [[ stms ^ (s, ty_func_outer) ]].


  [[ VarDecBinder(binder, exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty ]],
    Binder [[ binder ^ (s, ty) ]].
    
  [[ VarDec(id_var, ty) ^ (s, _) ]] :=
    [[ ty ^ (s) : ty_bound ]],
    Var{id_var} <- s,
    Var{id_var}.kind := LocalVarKind() !,
    Var{id_var} : ty_bound !.
    
  [[ Assign(exp_ref, exp_val) ^ (s, _) ]] :=
    [[ exp_ref ^ (s) : ty_ref ]],
    [[ exp_val ^ (s) : ty_val ]],
    ty_val <? ty_ref | error $[Type mismatch: expected [ty_ref], got [ty_val]] @ exp_val. 


  [[ If(exp, stm) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty]] @ exp,
    new s_if,
    s_if -P-> s,
    [[ stm ^ (s_if, ty_func_outer) ]].

  [[ IfElse(exp, stm_true, stm_false) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty]] @ exp,
    new s_if_true,
    s_if_true -P-> s,
    [[ stm_true ^ (s_if_true, ty_func_outer) ]],
    new s_if_false,
    s_if_false -P-> s,
    [[ stm_false ^ (s_if_false, ty_func_outer) ]].

  [[ ForEach(binder, exp, stm) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty ]],
    ty == ListTy(ty_inner) | error $[Type mismatch: expected list type, got [ty]] @ exp,
    new s_foreach,
    s_foreach -P-> s,
    Binder [[ binder ^ (s_foreach, ty_inner) ]],
    [[ stm ^ (s_foreach, ty_func_outer) ]].


  [[ Return(exp) ^ (s, ty_func_outer) ]] :=
    [[ exp ^ (s) : ty_ret ]],
    ty_func_outer == FuncTy(_, ty_ret_expected),
    ty_ret <? ty_ret_expected | error $[Type mismatch: expected [ty_ret_expected], got [ty_ret]] @ exp.

  [[ Fail(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? StrTy() | error $[Type mismatch: expected string type, got [ty]] @ exp.


  [[ Exp(exp) ^ (s, _) ]] :=
    [[ exp ^ (s) : _ ]].

rules // Unary expressions

  [[ ToNullable(exp) ^ (s) : NullableTy(ty) ]] :=
    [[ exp ^ (s) : ty ]],
    ty != NullableTy(_) | error $[Type mismatch: expected non-nullable type, got [ty]] @ exp.
    
  [[ ToNonNullable(exp) ^ (s) : ty_inner ]] :=
    [[ exp ^ (s) : ty ]],
    ty == NullableTy(ty_inner) | error $[Type mismatch: expected nullable type, got [ty]] @ exp.

rules // Binary expressions

  // TODO: should use LUB to work both ways. However, that requires separating nullability into a property 
  // of a type (by creating a tuple for each type), because otherwise LUB could always result into the top 
  // type TopTy(), instead of failing.
  [[ t@Eq(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? ty_l | error $[Type mismatch: cannot compare [ty_l] to [ty_r]] @ t.
  [[ t@Neq(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? ty_l | error $[Type mismatch: cannot compare [ty_l] to [ty_r]] @ t.

  [[ t@Lor(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    ty_l <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_l]] @ exp_l,
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_r]] @ exp_r.
  [[ t@Land(exp_l, exp_r) ^ (s) : BoolTy() ]] :=
    [[ exp_l ^ (s) : ty_l ]],
    ty_l <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_l]] @ exp_l,
    [[ exp_r ^ (s) : ty_r ]],
    ty_r <? BoolTy() | error $[Type mismatch: expected boolean type, got [ty_r]] @ exp_r.

rules // Variable reference
    
  [[ Ref(id_var) ^ (s) : ty ]] :=
    Var{id_var} -> s,
    Var{id_var} |-> v,
    v : ty.

rules // Function calls

  [[ Call(id_func, args) ^ (s) : ty_out ]] :=
    Func{id_func} -> s,
    Func{id_func} |-> f,
    f : ty_func,
    ty_func == FuncTy(tys_in_expected, ty_out) | error $[Type mismatch: expected function type, got [ty_func]] @ id_func,
    Map1T [[ args ^ (s) : tys_in ]],
    tys_in <? tys_in_expected | error $[Type mismatch: expected [tys_in_expected], got [tys_in]] @ id_func.

  [[ QCall(exp, id_func, args) ^ (s) : ty_out ]] :=
    [[ exp ^ (s) : ty_data ]],
    ty_data == DataTy(occ_data) | error $[Type mismatch: expected data type, got [ty_data]] @ exp, 
    occ_data ?=I=> s_assoc_data,
    new s_imp,
    s_imp -I-> s_assoc_data,
    Func{id_func} -> s_imp,
    Func{id_func} |-> f,
    f : FuncTy(tys_in_expected, ty_out),
    Map1T [[ args ^ (s) : tys_in ]], 
    tys_in <? tys_in_expected | error $[Type mismatch: expected [tys_in_expected], got [tys_in]] @ id_func.

rules // Simple literals

  [[ BoolLit(_) ^ (s) : BoolTy() ]] := true.
  [[ IntLit(_)  ^ (s) : IntTy()  ]] := true.
  [[ StrLit(_)  ^ (s) : StrTy()  ]] := true.
  [[ NullLit()  ^ (s) : NullTy() ]] := true.

rules // Composite literals

  [[ TupleLit(exps) ^ (s) : TupleTy(tys) ]] :=
    Map1T [[ exps ^ (s) : tys ]].

  [[ ListLit([]) ^ (s) : ListTy(TopTy()) ]] := true.

  [[ ListLit([exp|exps]) ^ (s) : ListTy(ty) ]] :=
    // TODO: this should calculate the LUB of the expression types.
    [[ exp ^ (s) : ty ]],
    CompareTypes [[ exps ^ (s, ty) ]].
    
  [[ ListAppendLit(exp, exps) ^ (s) : ty ]] :=
    // TODO: this should calculate the LUB of the expression types.
    [[ exp ^ (s) : ty ]],
    ty == ListTy(ty_inner) | error $[Type mismatch: expected list type, got [ty]] @ exp,
    CompareTypes [[ exps ^ (s, ty_inner) ]].
    
  CompareTypes [[ [exp|exps] ^ (s, ty_expected) ]] :=
    [[ exp ^ (s) : ty ]],
    ty <? ty_expected | error $[Type mismatch: expected [ty_expected], got [ty]] @ exp,
    CompareTypes [[ exps ^ (s, ty_expected) ]].

  CompareTypes [[ [] ^ (s, ty_expected) ]] := true.
