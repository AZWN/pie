module gen/type2java

imports

  libspoofax/stratego/debug

  signatures/-
  signatures/lex/-
  signatures/impl/-

  statsem/program
  
  gen/idtype-tuples
  gen/util

rules

  t2j-def-sig = t2j-sig(fail) 
  t2j-ref-sig = t2j-sig(id)

  t2j-sig(isref): VoidTy()             -> "void"
  t2j-sig(isref): NullableTy(VoidTy()) -> "void"

  t2j-sig(isref): BoolTy()             -> "bool"
  t2j-sig(isref): NullableTy(BoolTy()) -> "Boolean"           where isref
  t2j-sig(isref): NullableTy(BoolTy()) -> "@Nullable Boolean" where not(isref)
  
  t2j-sig(isref): IntTy()              -> "int"
  t2j-sig(isref): NullableTy(IntTy())  -> "Integer"           where isref
  t2j-sig(isref): NullableTy(IntTy())  -> "@Nullable Integer" where not(isref)
  
  t2j-sig(isref): StrTy()              -> "String"
  t2j-sig(isref): NullableTy(StrTy())  -> "String"           where isref
  t2j-sig(isref): NullableTy(StrTy())  -> "@Nullable String" where not(isref)
  
  t2j-sig(isref): TopTy()              -> "Object"
  t2j-sig(isref): NullableTy(TopTy())  -> "Object"           where isref
  t2j-sig(isref): NullableTy(TopTy())  -> "@Nullable Object" where not(isref)

  t2j-sig(isref):
    DataTy(occ) -> javaClassId
    where 
      JavaTypeKind() := <pipe-prop(|"Type", "kind")> occ
    with  
      javaClassId := <pipe-prop(|"Type", "javaClassId")> occ
  t2j-sig(isref):
    NullableTy(d@DataTy(ty)) -> <t2j-sig(isref)> d
    where isref
  t2j-sig(isref):
    NullableTy(d@DataTy(ty)) -> $[@Nullable [<t2j-sig(isref)> d]]
    where not(isref)
    
  t2j-sig(isref):
    t@TupleTy(tys) -> $[mb.pipe.run.core.util.ITuple]
  t2j-sig(isref):
    NullableTy(t@TupleTy(_)) -> <t2j-sig(isref)> t
    where isref
  t2j-sig(isref):
    NullableTy(t@TupleTy(_)) -> $[@Nullable [<t2j-sig(isref)> t]]
    where not(isref)

  t2j-sig(isref):
    ListTy(ty) -> $[Collection<[<t2j-sig(isref)> ty]>]
  t2j-sig(isref):
    NullableTy(l@ListTy(_)) -> <t2j-sig(isref)> l
    where isref
  t2j-sig(isref):
    NullableTy(l@ListTy(_)) -> $[@Nullable [<t2j-sig(isref)> l]]
    where not(isref)

rules

  t2j-singular-dataclass(is-static|name, nameSuffix, paramsPrefix, constructorStms):
    (typeId, ty) -> 
$[public[<(is-static; !" static") <+ !"">] class [name] [nameSuffix]{
    private static final long serialVersionUID = 1L;
    
    public final [<t2j-def-sig> ty] [typeId];
    
    public [name]([paramsPrefix][<t2j-def-sig> ty] [typeId]) {
        [constructorStms]
        this.[typeId] = [typeId];
    }
    
    public [<t2j-def-sig> ty] getPipeVal() {
        return [typeId];
    }
    
    @Override public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + (([typeId] == null) ? 0 : [typeId].hashCode());
        return result;
    }
    
    @Override public boolean equals(Object obj) {
        if(this == obj) return true;
        if(obj == null) return false;
        if(getClass() != obj.getClass()) return false;
        final [name] other = ([name]) obj;
        if([typeId] == null) { if(other.[typeId] != null) return false; } else if(![typeId].equals(other.[typeId])) return false;
        return true;
    }
}]

  t2j-multi-dataclass(is-static|name, nameSuffix, paramsPrefix, constructorStms):
    idTypeTuples -> 
$[public[<(is-static; !" static") <+ !"">] class [name] [nameSuffix]{
    private static final long serialVersionUID = 1L;
    
    [fields]
    
    public [name]([paramsPrefix][commaSep][params]) {
        [constructorStms]
        [assigns]
    }
    
    public mb.pipe.run.core.util.ITuple getPipeVal() {
        return new mb.pipe.run.core.util.Tuple([tupleValStr]);
    }
    
    @Override public int hashCode() {
        final int prime = 31;
        int result = 1;
        [hashCodeImpl]
        return result;
    }
    
    @Override public boolean equals(Object obj) {
        if(this == obj) return true;
        if(obj == null) return false;
        if(getClass() != obj.getClass()) return false;
        final [name] other = ([name]) obj;
        [equalsImpl]
        return true;
    }
}]
    with
      fieldStrs    := <map(\(typeId, ty) -> $[public final [<t2j-def-sig> ty] [typeId];]\)> idTypeTuples
    ; fields       := <pipe-sep-nl; concat-strings> fieldStrs
    ; paramStrs    := <map(\(typeId, ty) -> $[[<t2j-def-sig> ty] [typeId]]\)> idTypeTuples
    ; params       := <pipe-sep-comma; concat-strings> paramStrs
    ; commaSep     := <if ?[] then !"" else !", " end> idTypeTuples
    ; tupleValStrs := <map(\(typeId, _) -> typeId\)> idTypeTuples
    ; tupleValStr  := <pipe-sep-comma; concat-strings> tupleValStrs
    ; assignStrs   := <map(\(typeId, _) -> $[this.[typeId] = [typeId];]\)> idTypeTuples
    ; assigns      := <pipe-sep-nl; concat-strings> assignStrs
    ; hashCodeStrs := <map(\(typeId, _) -> $[result = prime * result + (([typeId] == null) ? 0 : [typeId].hashCode());]\)> idTypeTuples
    ; hashCodeImpl := <pipe-sep-nl; concat-strings> hashCodeStrs
    ; equalsStrs   := <map(\(typeId, _) -> $[if([typeId] == null) { if(other.[typeId] != null) return false; } else if(![typeId].equals(other.[typeId])) return false;]\)> idTypeTuples
    ; equalsImpl   := <pipe-sep-nl; concat-strings> equalsStrs

