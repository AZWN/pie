module gen/type2java

imports

  libspoofax/stratego/debug

  signatures/-
  signatures/lex/-
  signatures/impl/-

  statsem/program
  
  gen/idtype-tuples
  gen/util

rules

  t2j-def-sig = t2j-sig(fail) 
  t2j-ref-sig = t2j-sig(id)

  t2j-sig(isref): BoolTy()             -> "bool"
  t2j-sig(isref): NullableTy(BoolTy()) -> "Boolean"           where isref
  t2j-sig(isref): NullableTy(BoolTy()) -> "@Nullable Boolean" where not(isref)
  
  t2j-sig(isref): IntTy()              -> "int"
  t2j-sig(isref): NullableTy(IntTy())  -> "Integer"           where isref
  t2j-sig(isref): NullableTy(IntTy())  -> "@Nullable Integer" where not(isref)
  
  t2j-sig(isref): StrTy()              -> "String"
  t2j-sig(isref): NullableTy(StrTy())  -> "String"           where isref
  t2j-sig(isref): NullableTy(StrTy())  -> "@Nullable String" where not(isref)
  
  t2j-sig(isref): TopTy()              -> "Object"
  t2j-sig(isref): NullableTy(TopTy())  -> "Object"           where isref
  t2j-sig(isref): NullableTy(TopTy())  -> "@Nullable Object" where not(isref)

  t2j-sig(isref):
    DataTy(occ) -> javaClassId
    where 
      JavaTypeKind() := <debug1; pipe-prop(|"Type", "kind"); debug2> occ
    with  
      javaClassId := <debug2; pipe-prop(|"Type", "javaClassId"); debug3> occ
  t2j-sig(isref):
    NullableTy(d@DataTy(ty)) -> <t2j-sig(isref)> d
    where isref
  t2j-sig(isref):
    NullableTy(d@DataTy(ty)) -> $[@Nullable [<t2j-sig(isref)> d]]
    where not(isref)
    
  t2j-sig(isref):
    t@TupleTy(tys) -> $[List<Object>]
  t2j-sig(isref):
    NullableTy(t@TupleTy(_)) -> <t2j-sig(isref)> t
    where isref
  t2j-sig(isref):
    NullableTy(t@TupleTy(_)) -> $[@Nullable [<t2j-sig(isref)> t]]
    where not(isref)

  t2j-sig(isref):
    ListTy(ty) -> $[List<[<t2j-sig(isref)> ty]>]
  t2j-sig(isref):
    NullableTy(l@ListTy(_)) -> <t2j-sig(isref)> l
    where isref
  t2j-sig(isref):
    NullableTy(l@ListTy(_)) -> $[@Nullable [<t2j-sig(isref)> l]]
    where not(isref)

rules

  t2j-create-dataclass(is-static|name, nameSuffix, paramsPrefix, constructorStms):
    idTypeTuples -> 
$[public[<(is-static; !" static") <+ !"">] class [name] [nameSuffix]{
    private static final long serialVersionUID = 1L;
    
    [fields]
    
    public [name]([paramsPrefix][params]) {
        [constructorStms]
        [assigns]
    }
    
    @Override public int hashCode() {
        final int prime = 31;
        int result = 1;
        [hashCodeImpl]
        return result;
    }
    
    @Override public boolean equals(Object obj) {
        if(this == obj) return true;
        if(obj == null) return false;
        if(getClass() != obj.getClass()) return false;
        final [name] other = ([name]) obj;
        [equalsImpl]
        return true;
    }
}]
    with
      fieldStrs    := <map(\(typeId, ty) -> $[public final [<t2j-def-sig> ty] [typeId];]\)> idTypeTuples
    ; fields       := <pipe-sep-nl; concat-strings> fieldStrs
    ; paramStrs    := <map(\(typeId, ty) -> $[[<t2j-def-sig> ty] [typeId]]\)> idTypeTuples
    ; params       := <pipe-sep-comma; concat-strings> paramStrs
    ; assignStrs   := <map(\(typeId, _) -> $[this.[typeId] = [typeId];]\)> idTypeTuples
    ; assigns      := <pipe-sep-nl; concat-strings> assignStrs
    ; hashCodeStrs := <map(\(typeId, _) -> $[result = prime * result + (([typeId] == null) ? 0 : [typeId].hashCode());]\)> idTypeTuples
    ; hashCodeImpl := <pipe-sep-nl; concat-strings> hashCodeStrs
    ; equalsStrs   := <map(\(typeId, _) -> $[if([typeId] == null) { if(other.[typeId] != null) return false; } else if(![typeId].equals(other.[typeId])) return false;]\)> idTypeTuples
    ; equalsImpl   := <pipe-sep-nl; concat-strings> equalsStrs

