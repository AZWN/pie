module gen/kotlin-ceres/def

imports

  libspoofax/stratego/debug

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  gen/kotlin/type2kotlin
  gen/kotlin-ceres/stm

rules // definitions

  p2c-def:
    FuncDef(FuncHead(funcId, params, type), FuncImpl(Block(stms))) -> str
    with
      className   := <pipe-sanitize-class-id> funcId
    with
      (inputName , inputDataClass)  := <p2c-funcdef-inputsig(|className)> params
    ; (outputName, outputDataClass) := <p2c-funcdef-outputsig(|className)> type
    with
      buildImpl   := <p2c-stms> stms
    ; emptyReturn := <?VoidTy(); !"return Unit.instance" <+ !""> type
    with
      rules(ModuleBindings :+= $[binder.bindBuilder<[className]>(builders, "[className]")])
    with
      str := 
$[class [className] : Builder<[inputName], [outputName]> {
  [inputDataClass][outputDataClass]override val id = "[className]"
  override fun BuildContext.build(input: [inputName]): [outputName] {
    [buildImpl]
  }
}
]

  p2c-funcdef-inputsig(|className):
    Params(params) -> ("None", "")
    where
      0 := <length> params
      
  p2c-funcdef-inputsig(|className):
    p@Params(params) -> (tySig, "")
    where
      1 := <length> params
    with
      [(_, ty)] := <pipe-idtype-tuples> p
    ; tySig     := <t2k-sig> ty
    
  p2c-funcdef-inputsig(|className):
    p@Params(params) -> ($[[className].Input], $[[dataClassStr]["\n"]])
    where
      length := <length> params
    ; <gt> (length, 1)
    with
      idTypeTuples := <pipe-idtype-tuples> p
    ; dataClassStr := <t2k-generate-dataclass(|"Input")> idTypeTuples

    
  p2c-funcdef-outputsig(|className):
    ty -> (<t2k-sig> ty, "")
    where
      <not(?TupleTy(_))> ty
      
  p2c-funcdef-outputsig(|className):
    ty -> ($[[className].Output], $[[dataClassStr]["\n"]])
    where
      <?TupleTy(_)> ty
    with
      idTypeTuples := <pipe-idtype-tuples> ty
    ; dataClassStr := <t2k-generate-dataclass(|"Output")> idTypeTuples
