module gen/kotlin-ceres/exp

imports

  libspoofax/stratego/debug
  nabl2/api

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  statsem/program
  
  gen/kotlin-ceres/def
  gen/kotlin-ceres/listcomprehension
  gen/kotlin/type2kotlin
  gen/idtype-tuples
  gen/util
  gen/debug

rules 

  try-p2c-exp = pipe-try-debug(p2c-exp|"p2c-exp") <+ !"Any()"
  
rules // Nullable
  
  p2c-exp:
    ToNullable(exp) -> <p2c-exp> exp
    where
      NullableTy(ty) := <pipe-ast-type> exp

  p2c-exp:
    ToNullable(exp) -> $[[expStr] as [tySig]?]
    with
      ty := <pipe-ast-type> exp
    where
      not(NullableTy(_) := ty)
    with
      tySig  := <t2k-sig> ty
    ; expStr := <p2c-exp> exp

  p2c-exp:
    ToNonNullable(exp) -> $[[expStr]!!]
    with
      expStr := <p2c-exp> exp

  p2c-exp:
    Not(exp) -> $[![expStr]]
    with
      expStr := <p2c-exp> exp

rules // Binary expressions

  p2c-binexp(|symbol):
    (lExp, rExp) -> $[[lExpStr] [symbol] [rExpStr]]
    with
      lExpStr := <try-p2c-exp> lExp
    ; rExpStr := <try-p2c-exp> rExp
  
  p2c-exp: Eq(lExp, rExp) -> <p2c-binexp(|"==")> (lExp, rExp)
  p2c-exp: Neq(lExp, rExp) -> <p2c-binexp(|"!=")> (lExp, rExp)
  p2c-exp: Lor(lExp, rExp) -> <p2c-binexp(|"||")> (lExp, rExp)
  p2c-exp: Land(lExp, rExp) -> <p2c-binexp(|"&&")> (lExp, rExp)

rules // If else

  p2c-exp:
    If(condExp, exp) -> $[if([condExpStr]) [expStr]]
    with
      condExpStr := <try-p2c-exp> condExp
    ; expStr     := <try-p2c-exp> exp

  p2c-exp:
    IfElse(condExp, trueExp, falseExp) -> $[if([condExpStr]) [trueExpStr] else [falseExpStr]]
    with
      condExpStr  := <try-p2c-exp> condExp
    ; trueExpStr  := <try-p2c-exp> trueExp
    ; falseExpStr := <try-p2c-exp> falseExp

  p2c-exp:
    Add(lExp, rExp) -> $[[lExpStr] + [rExpStr]]
    with
      lExpStr := <try-p2c-exp> lExp
    ; rExpStr := <try-p2c-exp> rExp
    
rules // List comprehension

  p2c-exp:
    ListComprehensionExp(inner) -> $[[comprehension].toCollection([tyStr]())]
    with
      comprehension := <p2c-listcomprehension> inner
    ; ty            := <pipe-ast-type> inner
    ; tyStr         := <t2k-sig> ty

rules // References

  p2c-exp:
    r@Ref(varId) -> <p2c-ref-add-transient-val(|varId)> r 
    where
      LocalVarKind() := <pipe-ast-ref-prop(|"Var", "kind")> varId
  
  p2c-exp: 
    Ref(varId) -> <fail>
    where
      InputVarKind() := <pipe-ast-ref-prop(|"Var", "kind")> varId
    ; 0 := <InputKind>
      
  p2c-exp: 
    r@Ref(varId) -> <p2c-ref-add-transient-val(|"input")> r
    where
      InputVarKind() := <pipe-ast-ref-prop(|"Var", "kind")> varId
    ; 1 := <InputKind>
      
  p2c-exp: 
    r@Ref(varId) -> <p2c-ref-add-transient-val(|$[input.[varId]])> r
    where
      InputVarKind() := <pipe-ast-ref-prop(|"Var", "kind")> varId
    ; 2 := <InputKind>

  p2c-ref-add-transient-val(|str):
    ref -> $[[str].v]
    where
      <p2c-ref-is-transient> ref
    
  p2c-ref-add-transient-val(|str):
    ref -> str
    where
      <not(p2c-ref-is-transient)> ref
  
  p2c-ref-is-transient = 
      pipe-ast-type
    ; (?DataTy(<id>) <+ ?NullableTy(DataTy(<id>)))
    ; pipe-occ-prop(|"mods")
    ; collect-one(?Transient())

rules // External function calls

  p2c-exp:
    Call(funcId, exps) -> $[[javaClassId].[javaMethodId]([expStr])]
    where
      JavaStaticFuncKind() := <pipe-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId  := <pipe-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; javaMethodId := <pipe-ast-ref-prop(|"Func", "javaMethodId")> funcId
    ; expStr       := <map(try-p2c-exp); pipe-concat-comma> exps
    
  p2c-exp:
    Call(funcId, exps) -> $[[kotlinClassOrPackageId].[kotlinFuncId]([expStr])]
    where
      KotlinFuncKind() := <pipe-ast-ref-prop(|"Func", "kind")> funcId
    with
      kotlinClassOrPackageId := <pipe-ast-ref-prop(|"Func", "kotlinClassOrPackageId")> funcId
    ; kotlinFuncId           := <pipe-ast-ref-prop(|"Func", "kotlinFuncId")> funcId
    ; expStr                 := <map(try-p2c-exp); pipe-concat-comma> exps

rules // Data type function calls

  p2c-exp: 
    QCall(exp, funcId, argsExps) -> $[[expStr].[funcId]([argsExpStr])]
    with
      argsExpStr := <map(try-p2c-exp); pipe-concat-comma> argsExps
    ; expStr     := <try-p2c-exp> exp

rules // Ceres builder calls
  
  p2c-exp:
    c@Call(funcId, _) -> <p2c-exp-ceres-call(|javaClassId)> c
    where
      CeresBuilderFuncKind() := <pipe-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pipe-ast-ref-prop(|"Func", "javaClassId")> funcId
    
  p2c-exp: 
    c@Call(funcId, _) -> <p2c-exp-ceres-call(|javaClassId)> c 
    where
      PipelineFuncKind() := <pipe-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pipe-sanitize-class-id> funcId


  p2c-exp-ceres-call(|javaClassId):
   Call(funcId, exps) -> $[requireOutput([javaClassId]::class.java, [expStr])]
    with
      expStr := <p2c-exp-ceres-call-inputexp(|javaClassId)> exps


  p2c-exp-ceres-call-inputexp(|javaClassId):
    exps -> "None.instance"
    where
      0 := <length> exps

  p2c-exp-ceres-call-inputexp(|javaClassId):
    exps -> expStr
    where
      1 := <length> exps
    with
      [exp]  := exps
    ; expStr := <try-p2c-exp> exp
    
  p2c-exp-ceres-call-inputexp(|javaClassId):
    exps -> $[[javaClassId].Input([expStr])]
    where
      length := <length> exps
    ; <gt> (length, 1)
    with
      expStr := <map(try-p2c-exp); pipe-concat-comma> exps

rules // Requires / Generates

  p2c-exp:
    Requires(pathExp, matchPartOpt, stamper) -> $[require([pathExpStr], [stamperStr])]
    with
      pathExpStr := <p2c-exp> pathExp
    ; stamperStr := <p2c-stamper> (matchPartOpt, stamper)

  p2c-exp:
    Generates(pathExp, stamper) -> $[generates([pathExpStr], [stamperStr])]
    with
      pathExpStr := <p2c-exp> pathExp
    ; stamperStr := <p2c-stamper> (None(), stamper)
  
  p2c-stamper: (None(), Modified()) -> "ModifiedPathStamper()"
  p2c-stamper: (None(), Hash()    ) -> "HashPathStamper()"
  
  p2c-stamper:
    (f@Filter(_), Modified()) -> $[ModifiedPathStamper([filterStr])]
    with
      filterStr := <p2c-filter> f
  p2c-stamper:
    (f@Filter(_), Hash()) -> $[HashPathStamper([filterStr])]
    with
      filterStr := <p2c-filter> f

  p2c-filter:
    Filter(exp) -> $[PPaths.patternPathMatcher([expStr])]
    with
      expStr := <try-p2c-exp> exp

rules // Interpolated string

  p2c-exp:
    StrLit(parts) -> $["[partsStr]"]
    with
      partsStr := <map(p2c-strpart); concat-strings> parts

  p2c-strpart:
    Str(chars) -> chars

  p2c-strpart:
    StrInterpRef(refExp) -> $[$[refExpStr]]
    with
      refExpStr := <try-p2c-exp> refExp

  p2c-strpart:
    StrInterpExp(exp) -> $[${[expStr]}]
    with
      expStr := <try-p2c-exp> exp  

rules // Literals

  p2c-exp: BoolLit(True())  -> $[true]
  p2c-exp: BoolLit(False()) -> $[false]
  p2c-exp: IntLit(i)        -> i
  p2c-exp: PathLit(path)    -> $[PPathImpl(Paths.get("[path]")) as PPath]
  p2c-exp: NullLit()        -> $[null]
  
  p2c-exp:
    TupleLit(exps) -> $[tuple([expsStr])]
    with
      expsStr := <map(try-p2c-exp); pipe-concat-comma> exps
    
  p2c-exp:
    ListLit(exps) -> $[list([expsStr])]
    with
      expsStr := <map(try-p2c-exp); pipe-concat-comma> exps
